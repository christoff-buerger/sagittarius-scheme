;;; -*- mode:scheme; coding:utf-8; -*-
;;;
;;; crypto/key/eddsa.scm - EdDSA cipher
;;;
;;;  Copyright (c) 2021 Takashi Kato. All rights reserved.
;;;
;;;  Redistribution and use in source and binary forms, with or without
;;;  modification, are permitted provided that the following conditions
;;;  are met:
;;;
;;;  1. Redistributions of source code must retain the above copyright
;;;     notice, this list of conditions and the following disclaimer.
;;;
;;;  2. Redistributions in binary form must reproduce the above copyright
;;;     notice, this list of conditions and the following disclaimer in the
;;;     documentation and/or other materials provided with the distribution.
;;;
;;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

;; references:
;;  - [RFC 8032](https://datatracker.ietf.org/doc/html/rfc8032)

#!nounbound
(library (crypto eddsa)
    (export EdDSA Ed25519
	    <eddsa-key-parameter>
	    eddsa-key-parameter-curve 
	    <eddsa-private-key> eddsa-private-key?
	    eddsa-private-key-random eddsa-private-key-public-key
	    <eddsa-public-key> eddsa-public-key?
	    eddsa-public-key-data

	    )
    (import (rnrs)
	    (clos user)
	    (math)
	    (math ec)
	    (crypto key pair)
	    (sagittarius) ;; for bytevector->integer/endian
	    (core misc)	  ;; for define-vector-type;
	    (util bytevector)
	    )
;;; Interfaces
(define EdDSA :eddsa)
(define Ed25519 :ed25519)

(define-class <eddsa-key-parameter> ()
  ((curve :init-keyword :curve :reader eddsa-key-parameter-curve)))

(define-class <eddsa-private-key> (<private-key> <eddsa-key-parameter>)
  ((random :init-keyword :random :reader eddsa-private-key-random)
   (public-key :init-keyword :public-key :reader eddsa-private-key-public-key)))
(define (eddsa-private-key? o) (is-a? o <eddsa-private-key>))

(define-class <eddsa-public-key> (<public-key> <eddsa-key-parameter>)
  ((data :init-keyword :data :reader eddsa-public-key-data)))
(define (eddsa-public-key? o) (is-a? o <eddsa-public-key>))

(define-method generate-public-key ((m (eql Ed25519)) data)
  (generate-ed25519-public-key data))

(define-method generate-private-key ((m (eql Ed25519)) random)
  (generate-ed25519-private-key random))

(define-method generate-key-pair ((m (eql Ed25519))
				  ;; should we start using ChaCha20?
				  :key (prng (secure-random RC4)))

  (let* ((random (read-random-bytes prng 32))
	 (private-key (generate-ed25519-private-key random)))
    (make-keypair private-key
		  (eddsa-private-key-public-key private-key))))


;;; Ed25519 implementations
(define (generate-ed25519-public-key data)
  (make <eddsa-public-key> :data data :curve curve25519))

(define (generate-ed25519-private-key random)
    #|
5.1.5.  Key Generation

   The private key is 32 octets (256 bits, corresponding to b) of
   cryptographically secure random data.  See [RFC4086] for a discussion
   about randomness.

   The 32-byte public key is generated by the following steps.

   1.  Hash the 32-byte private key using SHA-512, storing the digest in
       a 64-octet large buffer, denoted h.  Only the lower 32 bytes are
       used for generating the public key.

   2.  Prune the buffer: The lowest three bits of the first octet are
       cleared, the highest bit of the last octet is cleared, and the
       second highest bit of the last octet is set.

   3.  Interpret the buffer as the little-endian integer, forming a
       secret scalar s.  Perform a fixed-base scalar multiplication
       [s]B.

   4.  The public key A is the encoding of the point [s]B.  First,
       encode the y-coordinate (in the range 0 <= y < p) as a little-
       endian string of 32 octets.  The most significant bit of the
       final octet is always zero.  To form the encoding of the point
       [s]B, copy the least significant bit of the x coordinate to the
       most significant bit of the final octet.  The result is the
       public key.
  |#
  (define (generate-public-key random)
    (let ((h (hash SHA-512 random))
	  (l (make-bytevector 32)))
      ;; 1
      (bytevector-copy! h 0 l 0 32)
      ;; 2
      (bytevector-u8-set! l 0  (bitwise-and #xF8 (bytevector-u8-ref l 0)))
      (bytevector-u8-set! l 31
			  (bitwise-ior #x40
			   (bitwise-and #x7F (bytevector-u8-ref l 31))))
      ;; 3
      (let* ((s (bytevector->integer/endian l (endianness little)))
	     (sB (ed-point-mul ed25519-parameter
			       (eddsa-parameter-B ed25519-parameter)
			       s)))
	;; 4
	(ed-point-encode-base ed25519-parameter sB
			      (eddsa-parameter-b ed25519-parameter)))))
  
  (let ((pub (generate-ed25519-public-key (generate-public-key random))))
    (make <eddsa-private-key> :curve curve25519
	  :random random :public-key pub)))

;; (define-vector-type eddsa-scheme
;;   (make-eddsa-scheme parameter prehash inithash) eddsa-scheme?
;;   (parameter eddsa-scheme-parameter)
;;   (prehash eddsa-scheme-prehash)
;;   (inithash eddsa-scheme-inithash))

;; (define ed25519-pure-scheme
;;   (make-eddsa-scheme ed25519-parameter
;;    values (lambda (data) (hash SHA-512 data))))


;; (define (ed25519-sign bv key :key (scheme ed25519-pure-scheme) (context #f))
;;   (define prehash (eddsa-scheme-prehash scheme))
;;   (define inithash (eddsa-scheme-inithash scheme))
;;   (define parameter (eddsa-scheme-parameter scheme))
;;   (define (sign
;;   )

;;; Twisted Edwards curve computation
;;; TODO should we make (math ed) and export them from there
(define-vector-type eddsa-parameter
  (make-eddsa-parameter name p b c n d a B L) eddsa-parameter?
  (name eddsa-parameter-name)
  (p eddsa-parameter-p)
  (b eddsa-parameter-b)
  (c eddsa-parameter-c)
  (n eddsa-parameter-n)
  (d eddsa-parameter-d)
  (a eddsa-parameter-a)
  (B eddsa-parameter-B)
  (L eddsa-parameter-L))

(define-vector-type ed-point
  (make-ed-point x y z t) ed-point?
  (x ed-point-x)
  (y ed-point-y)
  (z ed-point-z)
  (t ed-point-t))

;; Based on RFC 8032 Appendix A
;; field calculation (modular arith)
(define (ed-field-add p x y) (mod (+ x y) p))
(define (ed-field-sub p x y) (mod (- (+ x p) y) p))
(define (ed-field-mul p x y) (mod (* x y) p))
(define (ed-field-inv p x)   (mod (mod-expt x (- p 2) p) p))
(define (ed-field-div p x y) (ed-field-mul p x (ed-field-inv p y)))

;; Ed point calculation
(define ed-point-zero
  (let ((zero (make-ed-point 0 1 1 0)))
    (lambda (parameter)
      zero)))

(define (ed-point-add parameter x y)
  (case (eddsa-parameter-name parameter)
    ((ed25519) (ed25519-point-add parameter x y))
    (else (assertion-violation 'ed-point-add "Not supported"
			       (eddsa-parameter-name parameter)))))
(define (ed25519-point-add parameter x y)
  (define p (eddsa-parameter-p parameter))
  (define d (eddsa-parameter-d parameter))
  (define xx (ed-point-x x))
  (define xy (ed-point-y x))
  (define xt (ed-point-t x))
  (define xz (ed-point-z x))
  (define yx (ed-point-x y))
  (define yy (ed-point-y y))
  (define yt (ed-point-t y))
  (define yz (ed-point-z y))
  (let* ((zcp (ed-field-mul p xz yz))
	 (A (ed-field-mul p (ed-field-sub p xy xx) (ed-field-sub p yy yx)))
	 (B (ed-field-mul p (ed-field-add p xy xx) (ed-field-add p yy yx)))
	 (C (ed-field-mul p (ed-field-add p d d) (ed-field-mul p xt yt)))
	 (D (ed-field-add p zcp zcp))
	 (E (ed-field-sub p B A))
	 (H (ed-field-add p B A))
	 (F (ed-field-sub p D C))
	 (G (ed-field-add p D C)))
    (make-ed-point (ed-field-mul p E F) (ed-field-mul p G H)
		   (ed-field-mul p F G) (ed-field-mul p E H))))
	 

(define (ed-point-double parameter p)
  (case (eddsa-parameter-name parameter)
    ((ed25519) (ed25519-point-double parameter p))
    (else (assertion-violation 'ed-point-double "Not supported"
			       (eddsa-parameter-name parameter)))))
(define (ed25519-point-double parameter e)
  (define p (eddsa-parameter-p parameter))
  (define x (ed-point-x e))
  (define y (ed-point-y e))
  ;; (define t (ed-point-t e)) ;; not used
  (define z (ed-point-z e))
  (let* ((A (ed-field-mul p x x))
	 (B (ed-field-mul p y y))
	 (Ch (ed-field-mul p z z))
	 (C (ed-field-add p Ch Ch))
	 (H (ed-field-add p A B))
	 (xys (ed-field-add p x y))
	 (E (ed-field-sub p H (ed-field-mul p xys xys)))
	 (G (ed-field-sub p A B))
	 (F (ed-field-add p C G)))
    (make-ed-point (ed-field-mul p E F) (ed-field-mul p G H)
		   (ed-field-mul p F G) (ed-field-mul p E H))))

;; scalar multiplication
(define (ed-point-mul parameter p k)
  (unless (integer? k)
    (assertion-violation 'ed-point-mul "integer required for k" k))
  (do ((r (ed-point-zero parameter)
	  (if (odd? k) (ed-point-add parameter r s) r))
       (s p (ed-point-double parameter s))
       (k k (bitwise-arithmetic-shift-right k 1)))
      ((<= k 0) r)))

;; encode
(define (ed-point-encode-base parameter point b)
  (define p (eddsa-parameter-p parameter))
  (define x (ed-point-x point))
  (define y (ed-point-y point))
  (define z (ed-point-z point))
  (let ((xp (ed-field-div p x z))
	(yp (ed-field-div p y z)))
    (let ((s (integer->bytevector/endian yp (endianness little) (div b 8))))
      (when (odd? xp)
	(bytevector-u8-set! s (div (- b 1) 8)
	 (bitwise-ior
	  (bytevector-u8-ref s (div (- b 1) 8))
	  (bitwise-arithmetic-shift-left 1 (mod (- b 1) 8)))))
      s)))

;;; Ed25519 parameters
;; 5.1 Ed25519ph, Ed25519ctx, and Ed25519
(define ed25519-parameter
  (let ((xb #x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a)
	(yb #x6666666666666666666666666666666666666666666666666666666666666658)
	(p (ec-field-fp-p
	    (elliptic-curve-field (ec-parameter-curve curve25519))))
	(d #x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3))
    (make-eddsa-parameter
     'ed25519
     p	 ;; p = 2^255 - 19
     256 ;; b
     3	 ;; c 
     254 ;; n
     d	 ;; d
     -1	 ;; a
     (make-ed-point xb yb 1 (mod (* xb yb) p)) ;; B (x y z t)
     (ec-parameter-n curve25519) ;; n = order
     )))


)
