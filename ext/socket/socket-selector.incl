/* -*- mode:c -*- */
static int selector_sockets(SgSocketSelector *selector)
{
  /* filter closed socket */
  SgObject h = SG_NIL, t = SG_NIL, cp;
  int i = 0;
  Sg_LockMutex(&selector->lock);
  SG_FOR_EACH(cp, selector->sockets) {
    SgObject slot = SG_CAR(cp);
    if (Sg_SocketOpenP(SG_SOCKET(SG_CAR(slot)))) {
      SG_APPEND1(h, t, slot);
      i++;
    }
  }
  selector->sockets = h;
  Sg_UnlockMutex(&selector->lock);
  return i;
}

static int duplicate_socket(SgSocket *socket, SgObject sockets)
{
  SgObject cp;
  SG_FOR_EACH(cp, sockets) {
    if (SG_EQ(socket, SG_CAAR(cp))) return TRUE;
  }
  return FALSE;
}

static void strip_sockets(SgSocketSelector *selector, SgObject slots)
{
  if (!SG_NULLP(slots)) {
    /* remove the returned sockets from the targets */
    SgObject h = SG_NIL, t = SG_NIL, cp;
    SG_FOR_EACH(cp, selector->sockets) {
      if (SG_FALSEP(Sg_Memq(SG_CAR(cp), slots))) {
	SG_APPEND1(h, t, SG_CAR(cp));
      }
    }
    selector->sockets = h;
  }
}

static void selector_finalizer(SgObject self, void *data)
{
  Sg_CloseSocketSelector(SG_SOCKET_SELECTOR(self));
}

static struct timespec *selector_timespec(SgObject timeout, struct timespec *tm)
{
  if (SG_FALSEP(timeout)) return NULL;
  /* number = usec (the same as `select`) */
  if (SG_INTP(timeout)) {
    long val = SG_INT_VALUE(timeout);
    if (val < 0) goto badtv;
    tm->tv_sec = val / 1000000;
    tm->tv_nsec = (val % 1000000) * 1000;
    return tm;
  } else if (SG_BIGNUMP(timeout)) {
    long usec;
    SgObject sec;
    if (Sg_Sign(timeout) < 0) goto badtv;
    sec = Sg_BignumDivSI(SG_BIGNUM(timeout), 1000000, &usec);
    tm->tv_sec = Sg_GetInteger(sec);
    tm->tv_nsec = usec * 1000;
    return tm;
  } else if (SG_FLONUMP(timeout)) {
    long val = Sg_GetInteger(timeout);
    if (val < 0) goto badtv;
    tm->tv_sec = val / 1000000;
    tm->tv_nsec = (val % 1000000) * 1000;
    return tm;
  } else if (SG_PAIRP(timeout) && SG_PAIRP(SG_CDR(timeout))) {
    SgObject sec = SG_CAR(timeout);
    SgObject usec = SG_CADR(timeout);
    long isec, iusec;
    if (!Sg_IntegerP(sec) || !Sg_IntegerP(usec)) goto badtv;
    isec = Sg_GetInteger(sec);
    iusec = Sg_GetInteger(usec);
    if (isec < 0 || iusec < 0) goto badtv;
    tm->tv_sec = isec;
    tm->tv_nsec = iusec * 1000;
    return tm;
  } else if (SG_TIMEP(timeout)) {
    tm->tv_sec = SG_TIME(timeout)->sec;
    tm->tv_nsec = SG_TIME(timeout)->nsec;
    return tm;
  }
 badtv:
  Sg_Error(UC("timespec needs to be a real number (in microseconds), a list "
	      "of two integers (seconds and microseconds), or a time object "
	      "but got %S"),
	   timeout);
  return NULL;                /* dummy */
}

static void remove_socket(SgSocketSelector *selector, SgSocket *socket);

SgObject Sg_SocketSelectorClear(SgSocketSelector *selector)
{
  SgObject cp, sockets;
  if (Sg_SocketSelectorWaitingP(selector)) {
    Sg_Error(UC("There's a thread already waiting for %A"), selector);
  }
  selector_sockets(selector);
  sockets = selector->sockets;
  SG_FOR_EACH(cp, sockets) {
    remove_socket(selector, SG_SOCKET(SG_CAAR(cp)));
  }
  cp = selector->sockets;
  selector->sockets = SG_NIL;
  return cp;
}

static void add_socket(SgSocketSelector *selector, SgObject slot);

SgObject Sg_SocketSelectorAdd(SgSocketSelector *selector,
			      SgSocket *socket, SgObject data)
{
  if (Sg_SocketOpenP(socket) && !duplicate_socket(socket, selector->sockets)) {
    SgObject slot = Sg_Cons(socket, data);
    Sg_LockMutex(&selector->lock);
    add_socket(selector, slot);
    selector->sockets = Sg_Cons(slot, selector->sockets);
    selector_sockets(selector);
    Sg_UnlockMutex(&selector->lock);
  }
  return SG_OBJ(selector);
}

static void * make_selector_context();

SgObject Sg_MakeSocketSelector()
{
  SgSocketSelector *selector = SG_NEW(SgSocketSelector);
  SG_SET_CLASS(selector, SG_CLASS_SOCKET_SELECTOR);

  selector->sockets = SG_NIL;
  selector->waiting = FALSE;
  selector->context = make_selector_context();

  Sg_InitMutex(&selector->lock, TRUE);
  Sg_InitCond(&selector->cv);

  Sg_RegisterFinalizer(selector, selector_finalizer, NULL);
  return SG_OBJ(selector);
}

static SgObject selector_wait(SgSocketSelector *selector, int n, struct timespec *sp);

SgObject Sg_SocketSelectorWait(SgSocketSelector *selector, SgObject timeout)
{
  SgObject r;
  int n = selector_sockets(selector);
  struct timespec spec, *sp;
  
  if (selector->waiting) {
    Sg_Error(UC("There's a thread already waiting for %A"), selector);
  }
  if (n == 0) return SG_NIL;	/* nothing to wait */
  selector->waiting = TRUE;
  sp = selector_timespec(timeout, &spec);
  r = selector_wait(selector, n, sp);
  strip_sockets(selector, r);
  selector->waiting = FALSE;
  return r;  
}


int Sg_SocketSelectorWaitingP(SgSocketSelector *selector)
{
  return selector->waiting;
}
