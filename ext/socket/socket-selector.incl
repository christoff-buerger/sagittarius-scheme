/* -*- mode:c -*- */
static int selector_sockets(SgSocketSelector *selector)
{
  /* filter closed socket */
  SgObject h = SG_NIL, t = SG_NIL, cp;
  int i = 0;
  Sg_LockMutex(&selector->lock);
  SG_FOR_EACH(cp, selector->sockets) {
    SgObject slot = SG_CAR(cp);
    if (Sg_SocketOpenP(SG_SOCKET(SG_CAR(slot)))) {
      SG_APPEND1(h, t, slot);
      i++;
    }
  }
  selector->sockets = h;
  Sg_UnlockMutex(&selector->lock);
  return i;
}

static int duplicate_socket(SgSocket *socket, SgObject sockets)
{
  SgObject cp;
  SG_FOR_EACH(cp, sockets) {
    if (SG_EQ(socket, SG_CAAR(cp))) return TRUE;
  }
  return FALSE;
}

static void strip_sockets(SgSocketSelector *selector, SgObject slots)
{
  if (!SG_NULLP(slots)) {
    /* remove the returned sockets from the targets */
    SgObject h = SG_NIL, t = SG_NIL, cp;
    Sg_LockMutex(&selector->lock);
    SG_FOR_EACH(cp, selector->sockets) {
      if (SG_FALSEP(Sg_Memq(SG_CAR(cp), slots))) {
	SG_APPEND1(h, t, SG_CAR(cp));
      }
    }
    selector->sockets = h;
    Sg_UnlockMutex(&selector->lock);
  }
}

static void selector_finalizer(SgObject self, void *data)
{
  Sg_CloseSocketSelector(SG_SOCKET_SELECTOR(self));
}

static struct timespec *selector_timespec(SgObject timeout, struct timespec *tm)
{
  if (SG_FALSEP(timeout)) return NULL;
  /* number = usec (the same as `select`) */
  if (SG_INTP(timeout)) {
    long val = SG_INT_VALUE(timeout);
    if (val < 0) goto badtv;
    tm->tv_sec = val / 1000000;
    tm->tv_nsec = (val % 1000000) * 1000;
    return tm;
  } else if (SG_BIGNUMP(timeout)) {
    long usec;
    SgObject sec;
    if (Sg_Sign(timeout) < 0) goto badtv;
    sec = Sg_BignumDivSI(SG_BIGNUM(timeout), 1000000, &usec);
    tm->tv_sec = Sg_GetInteger(sec);
    tm->tv_nsec = usec * 1000;
    return tm;
  } else if (SG_FLONUMP(timeout)) {
    long val = Sg_GetInteger(timeout);
    if (val < 0) goto badtv;
    tm->tv_sec = val / 1000000;
    tm->tv_nsec = (val % 1000000) * 1000;
    return tm;
  } else if (SG_PAIRP(timeout) && SG_PAIRP(SG_CDR(timeout))) {
    SgObject sec = SG_CAR(timeout);
    SgObject usec = SG_CADR(timeout);
    long isec, iusec;
    if (!Sg_IntegerP(sec) || !Sg_IntegerP(usec)) goto badtv;
    isec = Sg_GetInteger(sec);
    iusec = Sg_GetInteger(usec);
    if (isec < 0 || iusec < 0) goto badtv;
    tm->tv_sec = isec;
    tm->tv_nsec = iusec * 1000;
    return tm;
  } else if (SG_TIMEP(timeout)) {
    tm->tv_sec = SG_TIME(timeout)->sec;
    tm->tv_nsec = SG_TIME(timeout)->nsec;
    return tm;
  }
 badtv:
  Sg_Error(UC("timespec needs to be a real number (in microseconds), a list "
	      "of two integers (seconds and microseconds), or a time object "
	      "but got %S"),
	   timeout);
  return NULL;                /* dummy */
}

static void remove_socket(SgSocketSelector *selector, SgSocket *socket);

SgObject Sg_SocketSelectorClear(SgSocketSelector *selector)
{
  SgObject cp, sockets;
  if (Sg_SocketSelectorWaitingP(selector)) {
    Sg_Error(UC("There's a thread already waiting for %A"), selector);
  }
  selector_sockets(selector);
  sockets = selector->sockets;
  SG_FOR_EACH(cp, sockets) {
    remove_socket(selector, SG_SOCKET(SG_CAAR(cp)));
  }
  cp = selector->sockets;
  selector->sockets = SG_NIL;
  return cp;
}

static void add_socket(SgSocketSelector *selector, SgObject slot);

SgObject Sg_SocketSelectorAdd(SgSocketSelector *selector,
			      SgSocket *socket, SgObject data)
{
  if (Sg_SocketOpenP(socket) && !duplicate_socket(socket, selector->sockets)) {
    SgObject slot = Sg_Cons(socket, data);
    Sg_LockMutex(&selector->lock);
    add_socket(selector, slot);
    selector->sockets = Sg_Cons(slot, selector->sockets);
    selector_sockets(selector);
    if (selector->waiting && !selector->retry) {
      selector->retry = TRUE;
      Sg_SocketSelectorInterrupt(selector);
    }
    Sg_UnlockMutex(&selector->lock);
  }
  return SG_OBJ(selector);
}

static void * make_selector_context();

SgObject Sg_MakeSocketSelector()
{
  SgSocketSelector *selector = SG_NEW(SgSocketSelector);
  SG_SET_CLASS(selector, SG_CLASS_SOCKET_SELECTOR);

  selector->sockets = SG_NIL;
  selector->waiting = FALSE;
  selector->retry = FALSE;
  selector->context = make_selector_context();

  Sg_InitMutex(&selector->lock, TRUE);
  Sg_InitCond(&selector->cv);

  Sg_RegisterFinalizer(selector, selector_finalizer, NULL);
  return SG_OBJ(selector);
}

static SgObject selector_wait(SgSocketSelector *selector, int n,
			      struct timespec *sp);

SgObject Sg_SocketSelectorWait(SgSocketSelector *selector, SgObject timeout)
{
  SgObject r;
  int n;
  unsigned long sec, usec;
  struct timespec spec, *sp, start;
  
  if (selector->waiting) {
    Sg_Error(UC("There's a thread already waiting for %A"), selector);
  }
  
  sp = selector_timespec(timeout, &spec);

  if (sp) {
    Sg_GetTimeOfDay(&sec, &usec);
    start.tv_sec = sec;
    start.tv_nsec = usec * 1000;
  }
  n = selector_sockets(selector);
  if (n == 0) return SG_NIL;	/* nothing to wait */
  selector->waiting = TRUE;

 retry:
  r = selector_wait(selector, n, sp);
  selector->waiting = FALSE;
  if (selector->retry) {
    Sg_LockMutex(&selector->lock);
    /*
      socket is added during waiting. here we do
      - update timeout
      - count socket
      - retry
     */
    if (sp) {
      unsigned long nsec;
      Sg_GetTimeOfDay(&sec, &usec);
      nsec = usec * 1000;
      sp->tv_sec = sp->tv_sec - (sec - start.tv_sec);
      sp->tv_nsec = sp->tv_nsec - (nsec - start.tv_nsec);
      start.tv_sec = sec;
      start.tv_nsec = nsec;
    }
    n = selector_sockets(selector);
    selector->waiting = TRUE;
    selector->retry = FALSE;
    Sg_UnlockMutex(&selector->lock);
    goto retry;
  } else {
    strip_sockets(selector, r);
  }

  return r;  
}


int Sg_SocketSelectorWaitingP(SgSocketSelector *selector)
{
  return selector->waiting;
}
