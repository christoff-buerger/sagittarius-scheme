#!nounbound
(library (sagittarius compiler pass3)
    (export pass3 init-pass3)
    (import (core)
	    (core base)
	    (core errors)
	    (for (compat r7rs) expand)
	    (sagittarius)
	    (sagittarius vm)
	    (sagittarius vm instruction)
	    (sagittarius compiler util)
	    (sagittarius compiler iform)
	    (sagittarius compiler pass2)
	    (sagittarius compiler procedure))

(include "smatch.scm")

(define (init-pass3 . ignore) #f)
  
(define (pass3 iform)
  (let loop ((iform iform))
    (let* ((label-dic (make-label-dic #f))
	   (iform. (pass3/rec (reset-lvars iform) label-dic)))
      (if (label-dic-info label-dic)
	  (loop iform.)
	  iform.))))

(define (pass3/rec iform labels)
  ((vector-ref *pass3-dispatch-table* (iform-tag iform)) iform labels))

(define (reset-lvars iform) (reset-lvars/rec iform (make-label-dic #f)) iform)
(define-syntax reset-lvars/rec*
  (syntax-rules ()
    ((_ iform labels)
     (ifor-each (lambda (x) (reset-lvars/rec x labels)) iform))))
(define (reset-lvars/rec iform labels)
  (case/unquote 
   (iform-tag iform)
   (($DEFINE ) (reset-lvars/rec ($define-expr iform) labels))
   (($LREF   ) (lvar-ref++! ($lref-lvar iform)))
   (($LSET   ) (lvar-set++! ($lref-lvar iform))
	       (reset-lvars/rec ($lset-expr iform) labels))
   (($GSET   ) (reset-lvars/rec ($gset-expr iform) labels))
   (($IF     ) (reset-lvars/rec ($if-test iform) labels)
	       (reset-lvars/rec ($if-then iform) labels)
	       (reset-lvars/rec ($if-else iform) labels))
   (($LET    ) (ifor-each lvar-reset ($let-lvars iform))
	       (reset-lvars/rec* ($let-inits iform) labels)
	       (reset-lvars/rec ($let-body iform) labels))
   (($LAMBDA ) (ifor-each lvar-reset ($lambda-lvars iform))
	       (reset-lvars/rec ($lambda-body iform) labels))
   (($RECEIVE) (ifor-each lvar-reset ($receive-lvars iform))
	       (reset-lvars/rec ($receive-expr iform) labels)
	       (reset-lvars/rec ($receive-body iform) labels))
   (($LABEL  ) (unless (label-seen? labels iform)
		 (label-push! labels iform)
		 (reset-lvars/rec ($label-body iform) labels)))
   (($SEQ    ) (reset-lvars/rec* ($seq-body iform) labels))
   (($CALL   ) (unless (eq? ($call-flag iform) 'jump)
		 (reset-lvars/rec ($call-proc iform) labels))
	       (reset-lvars/rec* ($call-args iform) labels))
   (($ASM    ) (reset-lvars/rec* ($asm-args iform) labels))
   (($LIST   ) (reset-lvars/rec* ($list-args iform) labels))
   (else #f)))


(define (pass3/$DEFINE iform labels)
  ($define-expr-set! iform (pass3/rec ($define-expr iform) labels))
  iform)
(define (pass3/$LREF iform labels) iform)
(define (pass3/$LSET iform labels)
  ($lset-expr-set! iform (pass3/rec ($lset-expr iform) labels))
  iform)

(define (pass3/$GREF iform labels) iform)
(define (pass3/$GSET iform labels)
  ($gset-expr-set! iform (pass3/rec ($gset-expr iform) labels))
  iform)

(define (pass3/$IF iform labels)
  (let ((test-form (pass3/rec ($if-test iform) labels))
	(then-form (pass3/rec ($if-then iform) labels))
	(else-form (pass3/rec ($if-else iform) labels)))
    (or (and-let* ((r (pass2/branch-cut iform test-form then-form else-form)))
	  (label-dic-info-set! labels #t)
	  r)
	(and
	 (has-tag? test-form $IF)
	 (let ((test-then ($if-then test-form))
	       (test-else ($if-else test-form)))
	   (cond ((has-tag? test-then $IT)
		  (receive (l0 l1) (pass3/label-or-dup then-form)
		    (pass2/update-if iform ($if-test test-form)
				     l0
				     (pass3/rec ($if #f test-else l1 else-form)
						labels))))
		 ((or ($it? test-else)
		      (and ($const? test-else)
			   (not ($const-value test-else))))
		  (receive (l0 l1)
		      (pass3/label-or-dup else-form)
		    (pass2/update-if iform ($if-test test-form)
				     (pass3/rec ($if #f test-then then-form l0)
						labels)
				     l1)))
		 ((and ($const? test-then)
		       (not ($const-value test-then)))
		  (receive (l0 l1)
		      (pass3/label-or-dup else-form)
		    (pass2/update-if iform ($if-test test-form)
				     (if ($it? l0) ($const-f) l0)
				     (pass3/rec ($if #f test-else then-form l1)
						labels))))
		 (else #f))))
	(pass2/update-if iform test-form then-form else-form))))

(define (pass3/label-or-dup iform)
  (if (memv (iform-tag iform) `(,$LREF ,$CONST ,$IT))
      (values iform (iform-copy iform '()))
      (let ((lab ($label #f #f iform)))
	(values lab lab))))

(define (pass3/$LET iform labels) 
  (let ((lvars ($let-lvars iform))
	(inits (imap (lambda (init) (pass3/rec init labels))
		     ($let-inits iform))))
    (ifor-each2 (lambda (lv in) (lvar-initval-set! lv in)) lvars inits)
    (pass2/shrink-let-frame iform lvars (pass3/rec ($let-body iform) labels))))

(define (pass3/$RECEIVE iform labels)
  ($receive-expr-set! iform (pass3/rec ($receive-expr iform) labels))
  ($receive-body-set! iform (pass3/rec ($receive-body iform) labels))
  iform)

(define (pass3/$LABEL iform labels)
  (unless (label-seen? labels iform)
    (label-push! labels iform)
    ($label-body-set! iform (pass3/rec ($label-body iform) labels)))
    iform)

(define (pass3/$LAMBDA iform labels)
  ($lambda-body-set! iform (pass3/rec ($lambda-body iform) labels))
  iform)

(define (pass3/$SEQ iform labels)
  (let ((xs ($seq-body iform)))
    (if (null? xs)
	iform
	(let loop ((r '()) (xs xs))
	  (smatch xs
	    ((x)
	     (cond ((null? r) (pass3/rec x labels))
		   (else
		    ($seq-body-set!
		     iform
		     (reverse! (cons (pass3/rec x labels) r)))
		    iform)))
	    ((x . xs)
	     (let ((x. (pass3/rec x labels)))
	       (loop (if (transparent? x.) r (cons x. r)) xs))))))))

(define (check-argumens iform)
  (define (err-msg-fmt opt?)
    (if opt?
	"wrong number of arguments: ~a requires at least ~a, but got ~a"
	"wrong number of arguments: ~a requires ~a, but got ~a"))
  (and-let* ((proc ($call-proc iform))
	     ( ($gref? proc) )
	     (id ($gref-id proc)) 
	     (g (find-binding (id-library id) (id-name id) #f))
	     (b (gloc-ref g))
	     ( (or (subr? b) (closure? b)) ))
    (let ((given (length ($call-args iform)))
	  (req (procedure-reqargs b))
	  (opt? (procedure-optional? b)))
      (when (or (and (not opt?) (not (= req given)))
		(and opt? (< given req)))
	;; Should we reuse this?
	(if (vm-error-unbound?)
	    (error (id-name id)
		   (format/ss (err-msg-fmt opt?) (id-name id) req given))
	    ($vm-warn (err-msg-fmt opt?)
		      (id-name id) req given))))))
(define (pass3/$CALL iform labels)
  (check-argumens iform)
  ($call-args-set! iform (imap (lambda (arg) (pass3/rec arg labels))
			       ($call-args iform)))
  (case ($call-flag iform)
    ((jump) iform)
    ((embed) ($call-proc-set! iform (pass3/rec ($call-proc iform) labels))
	     iform)
    (else (pass3/optimize-call iform labels))))

;; TODO should we move pass2's inline here since it's got messy there...
(define (pass3/optimize-call iform labels)
  (let ((proc (pass3/rec ($call-proc iform) labels))
	(args ($call-args iform)))
    (cond ((has-tag? proc $LET)
	   ;; ($call ($let (...) body) args ...)
	   ;; -> ($let (...) ($call body args ...))
	   (let loop ((node proc)
		      (body ($let-body proc)))
	     (cond ((has-tag? body $LET) (loop body ($let-body body)))
		   (else ($call-proc-set! iform body)
			 ($let-body-set! node iform)
			 (pass3/$LET proc labels)))))
	  ((and-let* (( ($gref? proc) )
		      ( (for-all $const? args) )
		      (p (inlinable-binding? ($gref-id proc) #f)))
	     (pass3/precompute-procedure ($call-src iform) p args)))
	  ((has-tag? proc $LAMBDA)
	   ;; ($call ($lambda (...) body) args ...)
	   ;; -> inline it
	   (pass3/inline-call iform proc args labels))
	  (else ($call-proc-set! iform proc) iform))))

(define (pass3/precompute-procedure src p args)
  (guard (e (else (constant-folding-warning src (procedure-name p) args)))
    (let-values ((r (apply p (imap $const-value args))))
      (smatch r
	(()  ($undef))
	((r) ($const r))
	(_   ;; return as $ASM better than calling procedure
	 ($asm #f `(,VALUES ,(length r))
	       (imap (lambda (v) ($const v)) r)))))))

(define (pass3/inline-call call-node proc args labels)
  (label-dic-info-set! labels #t)
  (expand-inlined-procedure ($call-src call-node) proc args))

(define (pass3/$UNDEF iform labels) iform)
(define (pass3/$CONST iform labels) iform)
(define (pass3/$IT iform labels) iform)
(define (pass3/$LIBRARY iform labels) iform)

(define (pass3/$ASM iform labels)
  (let ((args (imap (lambda (arg) (pass3/rec arg labels)) ($asm-args iform))))
    (pass2/check-constant-asm iform args)))
(define (pass3/$LIST iform labels)
  ($*-args-set! iform (imap (lambda (arg) (pass3/rec arg labels))
			    ($*-args iform)))
  iform)

(define *pass3-dispatch-table* (generate-dispatch-table pass3))
)
