#!/bin/sh
#| -*- mode:scheme; coding:utf-8; -*-
exec sagittarius $0 "$@"
|#
#!read-macro=sagittarius/regex
(import (rnrs)
	(sagittarius)
	(sagittarius control)
	(sagittarius process)
	(sagittarius io)
	(util file)
	(util port)
	(match)
	(clos user)
	(sagittarius cgen unit)
	(sagittarius cgen precomp)
	(srfi :1)
	(srfi :39 parameters)
	(binary io) ;; including get-line as well
	(math)
	(getopt))

(define *verbose* (make-parameter #f))

(define *cache-load-path* (make-parameter '()))
(define *cache-load-path-append* (make-parameter '()))

(define (print . args)
  (for-each (lambda (l) (display l)) args) (newline))

(define (printe . args)
  (for-each (lambda (l) (display l (current-error-port))) args)
  (newline (current-error-port)))

(define (printv . args) (when (*verbose*) (apply printe args)))

(define (collect-imports&exprs exprs)
  (let-values (((imports exprs)
		(partition (match-lambda (('import rest ...) #t) (_ #f))
			   exprs)))
    (values (append-map (lambda (i) (cdr i)) imports) exprs)))

(define (error-reader process stdout stderr transcoder)
  (let ((perr (process-error-port process)))
    (let loop ((l (get-line perr)))
      (put-bytevector stderr l)
      (put-u8 stderr #x0a)
      (unless (#/loaded/ l) (loop (get-line perr))))
    process))

(define +sagittarius+
  (or (getenv "SAGITTARIUS")
      (cond-expand
       ;; for Windows it must be this
       (windows "sash")
       (else "sagittarius"))))
(define (cache-imports imports :key (stderr #f))
  (define expr (format "(begin ~s) (exit)" (cons 'import imports)))
  (define (construct-args expr)
    `(,@(if stderr '("-Einfo") '())
      "-e" ,expr
      ,@(map (lambda (p) (string-append "-L" p)) (*cache-load-path*))
      ,@(map (lambda (p) (string-append "-A" p)) (*cache-load-path-append*))))
  
  (let ((p (create-process +sagittarius+
			   (construct-args expr)
			   :stdout (current-output-port)
			   :stderr stderr
			   :transcoder #f
			   :reader (if stderr error-reader #f))))
    (unless (zero? (process-run p))
      (error "library caching" "failed to execute sagittarius process"))))

(define-class <image-cache> ()
  ((image :init-keyword :image)
   (name  :init-keyword :name)))
(define-class <c-code> ()
  ((code :init-keyword :code)
   (initfun :init-keyword :initfun)))

(define (genenerate-toplevel)
  (string-append "_" (number->string (microsecond) 32)))
(define-class <scheme2c-unit> (<cgen-precomp-unit>)
  ((toplevel :init-thunk genenerate-toplevel)))

(define (name-generator-generator box)
  (lambda args
    (let-values (((out-file init-fun)
		  (apply cgen-default-name-generator args)))
      (vector-set! box 0 init-fun)
      (values out-file init-fun))))

;; FIXME it's possible not to call sagittarius process to cache.
(define (retrieve-caches imports need-eval?)
  (define in/out (open-chunked-binary-input/output-port))
  (define expr '(begin (display "version: " (current-error-port))
		       (display (sagittarius-version) (current-error-port))
		       (newline (current-error-port))))
  (define (->cache line)
    (cond ((#/read cache of "(.+?)"/ line) =>
	   (lambda (m)
	     (let ((file (utf8->string (m 1))))
	       (let* ((exprs (file->sexp-list file))
		      (boxes (map (lambda (e) (make-vector 1)) exprs))
		      (code* (map (lambda (expr box)
				    (printv "Compiling: " file)
				    (let ((generator
					   (name-generator-generator box)))
				      (with-output-to-string
					(lambda ()
					  (cgen-precompile expr
					     :in-file file
					     :name-generator generator
					     :unit-class <scheme2c-unit>
					     :need-macro? need-eval?)))))
				  exprs boxes)))
		 (if (null? (cdr code*))
		     (list (make <c-code> :code (car code*)
				 :initfun (vector-ref (car boxes) 0)))
		     ;; needs to be reversed
		     (reverse!
		      (map (lambda (code box)
			     (make <c-code> :code code
				   :initfun (vector-ref box 0)))
			   code* boxes)))))))
	  (else #f)))
  (cache-imports imports :stderr in/out)
  (set-port-position! in/out 0)
  (reverse!
   (port-fold (lambda (line r)
		(let ((cache (->cache line)))
		  (cond ((not cache) r)
			((pair? cache) (append cache r))
			(else (cons cache r)))))
	      '() (lambda () (get-line in/out)))))
   
(define (generate-unique-library-name) (list (gensym)))

(define (emit-raw code)
  (if (list? code)
      (for-each print code)
      (print code)))

(define-method cgen-emit-c ((unit <cgen-precomp-unit>))
  (cgen-emit-preamble unit)
  (cgen-emit-part unit 'decl)
  (cgen-emit-static-data unit)
  (cgen-emit-part unit 'body)
  (cgen-emit-prologue unit)
  (cgen-emit-part unit 'init)
  (cgen-emit-epilogue unit))

(define-method emit-static-cache ((cache <image-cache>))
  (define image (slot-ref cache 'image))
  (print "static uint8_t " (slot-ref cache 'name) "[] = {")
  (dotimes (i (bytevector-length image))
    (unless (zero? i) (display ", "))
    (when (and (not (zero? i)) (zero? (mod i 15))) (newline))
    (format #t "0x~2,'0x" (bytevector-u8-ref image i)))
  (print "};"))

(define-method emit-static-cache ((cache <c-code>))
  (print (slot-ref cache 'code)))

(define-method emit-cache-init ((cache <image-cache>))
  (format #t "  Sg_ReadCacheFromImage(~a, ~a);~%"
	  (slot-ref cache 'name)
	  (bytevector-length (slot-ref cache 'image))))

(define-method emit-cache-init ((cache <c-code>))
  (format #t "  Sg__Init_~a();~%" (slot-ref cache 'initfun)))

(define (emit-static-caches caches)
  (print "#include <stdint.h>")
  (for-each emit-static-cache caches))

(define library-name->string
  (with-library (sagittarius cgen precomp) library-name->string))

(define (emit-execution-code lib caches)
  (let ((init-this (format "Sg__Init_~a()" (library-name->string lib))))
    (print "static SgObject argsToList(char** argv, int argc)")
    (print "{")
    (print "  SgObject h = SG_NIL, t = SG_NIL;")
    (print "  int i;")
    (print "  for (i = 0; i < argc; i++) {")
    (print "    SG_APPEND1(h, t, Sg_MakeStringC(argv[i]));")
    (print "  }")
    (print "  return h;")
    (print "}")

    (print "int main(int argc, char **argv)")
    (print "{")
    (print "  SgObject lib, m, r, cmd;")
    (print "  Sg_Init();")
    (print "  SG_VM_SET_FLAG(Sg_VM(), SG_WARN_LEVEL);")
    (print "  cmd = argsToList(argv, argc);")
    (print "  lib = Sg_FindLibrary(SG_INTERN(\"(core program)\"), FALSE);")
    (print "  m = Sg_FindBinding(lib, SG_INTERN(\"command-line\"), SG_UNBOUND);")
    (print "  if (!SG_UNBOUNDP(m)) Sg_Apply1(SG_GLOC_GET(SG_GLOC(m)), cmd);")
    (for-each emit-cache-init caches)
    (print "  " init-this ";")
    (format #t  "  lib = Sg_FindLibrary(SG_INTERN(\"~a\"), FALSE);~%"
	    (cgen-decode-library-name (cgen-encode-library-name lib)))
    (print "  m = Sg_FindBinding(lib, SG_INTERN(\"main\"), SG_UNBOUND);")
    (print "  if (SG_UNBOUNDP(m)) return 0;")
    (print "  Sg_VM()->currentLibrary = lib;")
    (print "  r = Sg_Apply1(SG_GLOC_GET(SG_GLOC(m)), cmd);")
    (print "  return SG_INTP(r)? SG_INT_VALUE(r): 0;")
    (print "}")))

(define (usage)
  (printe "sagittarius-scheme2c [OPTIONS] file")
  (printe "OPTIONS")
  (printe " -h,--help")
  (printe"     show this message and quit")
  (printe " -o $OUTPUT,--output=$OUTPUT")
  (printe "    specifying output C file")
  (exit -1))

(define (main args)
  (define (get-out o)
    (if o
	(open-file-output-port
	   o (file-options no-fail) (buffer-mode block) (native-transcoder))
	(current-output-port)))
  (with-args (cdr args)
      ((h          (#\h "help") #f #f)
       (o          (#\o "output") #t #f)
       (need-eval? (#\e "enable-eval") #f #f)
       (verbose    (#\V "verbose") #f #f)
       (load-path  (#\L "loadpath") * '())
       (append-load-path  (#\A "append-loadpath") * '())
       . rest)
    (when h (usage))
    (when (null? rest) (usage))
    (*cgen-show-warning* #f)
    (*verbose* verbose)
    (*cache-load-path* load-path)
    (*cache-load-path-append* append-load-path)
    
    (let ((file (car rest)))
      (unless (file-exists? file)
	(printe "Specified file does not exists: " file)
	(exit -1))
      (printv "file: " file)
      (unless (null? load-path) (for-each add-load-path load-path))
      (unless (null? append-load-path)
	(for-each (lambda (p) (add-load-path p #t)) append-load-path))
      (let ((exprs (file->sexp-list file))
	    (library-name (generate-unique-library-name)))
	(let-values (((imports exprs) (collect-imports&exprs exprs)))
 	  (printv "caching ")
 	  (when verbose (for-each (lambda (i) (printv "  " i)) imports))
 	  (printv "...")
 	  (cache-imports imports)
 	  (printv "done! ")
	  (let ((c-body (with-output-to-string
			  (lambda ()
			    (cgen-precompile `(library ,library-name
						;; may get warning but
						;; need this
						(export main)
						(import ,@imports)
						,@exprs)
					     :need-macro? need-eval?
					     :in-file file))))
		(caches (retrieve-caches imports need-eval?))
		(out (get-out o)))
	    (with-output-to-port out
	      (lambda ()
		(emit-static-caches caches)
		(print c-body)
		(emit-execution-code library-name caches)))
	    (flush-output-port out)
	    (close-port out)))))))
			
