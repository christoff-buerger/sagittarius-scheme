#!/bin/env sash

#!read-macro=sagittarius/regex
(import (rnrs) (util file) (sagittarius regex) (pp)
	(srfi :13)
	(sagittarius control)
	(getopt))

(define r7rs-large-lists
  '(
    ((srfi 1  ) (scheme list) #f)
    ((srfi 133) (scheme vector) #f)
    ((srfi 132) (scheme sort) #f)
    ((srfi 113) (scheme set) #f)
    ((srfi 14 ) (scheme charset) #f)
    ((srfi 125) (scheme hash-table) #f)
    ((srfi 116) (scheme ilist) #f)
    ((srfi 101) (scheme rlist)
     ((prefix r)
      (rename (rmake-list make-rlist)
	      (rrandom-access-list->linear-access-list
	       rlist->list)
	      (rlinear-access-list->random-access-list
	       list->rlist))))
    ((srfi 134) (scheme ideque) #f)
    ((srfi 135) (scheme text) #f)
    ;; (121 (scheme generator) #f) ;; Tangerine supersedes this...
    ((srfi 127) (scheme lseq) #f)
    ((srfi 41 ) (scheme stream) #f)
    ((srfi 111) (scheme box) #f)
    ((srfi 115) (scheme regex) #f)
    ((srfi 117) (scheme list-queue) #f)
    ((srfi 124) (scheme ephemeron) #f)
    ((srfi 128) (scheme comparator) #f)
    ((srfi 141) (scheme division) #f)
    ((srfi 143) (scheme fixnum) #f)
    ((srfi 144) (scheme flonum) #f)
    ((srfi 146) (scheme mapping) #f)
    ((srfi 146 hash) (scheme mapping hash) #f)
    ((srfi 151) (scheme bitwise) #f)
    ((srfi 158) (scheme generator) #f)
    ((srfi 159) (scheme format) #f)
    ((rnrs bytevectors) (scheme bytevector) #f)
    ))

(define (ensure-dir file)
  (let-values (((base name ext) (decompose-path file)))
    (unless (file-exists? base) (create-directory* base))))

(define (generate-r7rs-large sitelib-dir)
  (define (library-name->file name)
    (string-append (apply build-path* (map symbol->string name)) ".scm"))
  (define (->import-spec base-lib spec)
    (if spec
	(do ((spec spec (cdr spec))
	     (lib base-lib (cons* (caar spec) lib (cdar spec))))
	    ((null? spec) lib))
	base-lib))
  (dolist (lib r7rs-large-lists)
    (let ((base-lib (car lib))
	  (file (build-path sitelib-dir (library-name->file (cadr lib))))
	  (lib-name (cadr lib))
	  (import-spec (caddr lib)))
      (ensure-dir file)
      (when (file-exists? file) (delete-file file))
      (call-with-output-file file
	(lambda (out)
	  (display +prelude+ out) (newline out)
	  (pp `(define-library ,lib-name
		 (export :all :export-reader-macro)
		 (import ,(->import-spec base-lib import-spec)))
	      out))))))
  

(define (usage args)
  (print "Usage: r7rs-srfi-gen.scm -p [SRFI dir] [-s sitelib-dir]")
  (exit -1))

(define-constant +prelude+ 
  ";; This file is automatically generated. DO NOT EDIT!!")

(define nested-srfis
  '(#/%3a146[\/\\]hash/)) ;; |

(define (create p pattern full-path? clean?)
  (define (file->srfi-libary opath)
    (define (convert s)
      (let ((v (regex-replace-all #/%3a/ s ":")))
	(or (string->number v)
	    (string->symbol v))))
    (define path (string-map (lambda (c) (if (eqv? c #\\) #\/ c)) opath))
    (print path)
    (cond ((#/srfi\/(.+)\.scm$/ path) =>
	   (lambda (m)
	     (let ((names (string-split (m 1) "/")))
	       (cons 'srfi (map convert names)))))))
  (let ((files (find-files p :pattern pattern
			   :check-full-path? full-path?)))
    (dolist (file files)
      (let ((new-file (regex-replace-all #/%3a/ file "")))
	;; remove file if it's there
	(when (file-exists? new-file) (delete-file new-file))
	(ensure-dir new-file)
	(unless clean?
	  (call-with-output-file new-file
	    (lambda (out)
	      (display +prelude+ out) (newline out)
	      (pp `(define-library ,(file->srfi-libary new-file)
		     (export :all :export-reader-macro)
		     (import ,(file->srfi-libary file)))
		  out))))))))

(define (main args)
  (with-args (cdr args) 
      ((p* (#\p "path") * (usage args))
       (sitelib (#\s "sitelib") #t "sitelib")
       (clean? (#\c "clean") #f #f))
    (dolist (p p*)
      (create p #/^%3a\d+\.scm/ #f clean?)
      (dolist (rule nested-srfis)
	(create p rule #t clean?)))
    (generate-r7rs-large sitelib)))
