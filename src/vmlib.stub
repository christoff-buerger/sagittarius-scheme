;; -*- scheme -*-
;; for Ypsilon
#!compatible
(library (sagittarius vm)
    (export :all)
    (import :none)
  (decl-code
   (.define "LIBSAGITTARIUS_BODY")
   (.include <sagittarius.h>
	     <sagittarius/instruction.h>))

  ;; TODO duplicated definition in Scheme
  (decl-code
   (.define "BOUNDARY"   "SG_MAKE_INT(3)")
   (.define "ENV_BOTTOM" "SG_MAKE_INT(4)"))

  (define-cise-stmt assertion-violation
    ((_ who msg)
     `(begin
	(Sg_AssertionViolation ,who (SG_MAKE_STRING ,msg) '())))
    ((_ who msg irritants)
     `(begin
	(Sg_AssertionViolation ,who (SG_MAKE_STRING ,msg) ,irritants)
	 )))

  (define-cise-stmt wrong-type-of-argument-violation
    ((_ who msg got)
     `(begin
	(Sg_WrongTypeOfArgumentViolation ,who (SG_MAKE_STRING ,msg) ,got '())))
    ((_ who msg got irritants)
     `(begin
	(Sg_WrongTypeOfArgumentViolation ,who (SG_MAKE_STRING ,msg) ,got ,irritants))))

  (define-c-proc insn-name (insn::<fixnum>)
    (let ((info::InsnInfo* (Sg_LookupInsnName insn)))
      (result (Sg_MakeStringC (-> info name)))))

  ;; identifier
  (define-c-proc make-identifier (name envs maybe-library)
    (unless (or (SG_SYMBOLP name) (SG_IDENTIFIERP name))
      (wrong-type-of-argument-violation 'make-identifier 
					"symbol or identifier" name))
    (unless (SG_LIBRARYP maybe-library)
      (set! maybe-library (Sg_FindLibrary maybe-library FALSE)))
    (result (Sg_MakeIdentifier name envs maybe-library)))

  (define-c-proc make-pending-identifier (name::<symbol> envs maybe-library)
    (unless (SG_LIBRARYP maybe-library)
      (set! maybe-library (Sg_FindLibrary maybe-library FALSE)))
    (let ((r (Sg_MakeIdentifier name envs maybe-library)))
      (set! (SG_IDENTIFIER_PENDING r) TRUE)
      (result r)))
  (define-c-proc pending-identifier? (o) ::<boolean>
    (result (and (SG_IDENTIFIERP o) (SG_IDENTIFIER_PENDING o))))

  (define-c-proc rename-pending-identifier! (id::<identifier>)
    (when (SG_IDENTIFIER_PENDING id)
      (set! (SG_IDENTIFIER_NAME id) 
	    (Sg_Gensym (-> (SG_SYMBOL (SG_IDENTIFIER_NAME id)) name)))
      ;; Issue 86
      ;; now pending identifiers hold macro environment but when it needs to
      ;; be renamed, it must hold use environment as its context.
      (set! (SG_IDENTIFIER_LIBRARY id) (Sg_VMCurrentLibrary)))
    (result id))

  (define-c-proc make-pattern-identifier (name envs maybe-library)
    (unless (or (SG_SYMBOLP name) (SG_IDENTIFIERP name))
      (wrong-type-of-argument-violation 'make-identifier 
					"symbol or identifier" name))
    (unless (SG_LIBRARYP maybe-library)
      (set! maybe-library (Sg_FindLibrary maybe-library FALSE)))
    (let ((id (Sg_MakeIdentifier name envs maybe-library)))
      ;;(set! (SG_IDENTIFIER_PENDING id) TRUE)
      (result id)))

  (define-c-proc id-envs (id::<identifier>) SG_IDENTIFIER_ENVS)

  (define-c-proc id-library (id::<identifier>) SG_IDENTIFIER_LIBRARY)

  ;; syntax
  (define-c-proc make-syntax (name::<symbol> proc) Sg_MakeSyntax)

  (define-c-proc syntax-name (arg0::<syntax>) SG_SYNTAX_NAME)

  (define-c-proc syntax-proc (arg0::<syntax>) SG_SYNTAX_PROC)

  (define-c-proc syntax? (arg0) ::<boolean> SG_SYNTAXP)

  (define-c-proc call-syntax-handler (s::<syntax> expr p1env) ::<top>
    (result (Sg_VMApply2 (SG_SYNTAX_PROC s) expr p1env)))

  ;; macro
  (define-c-proc macro? (obj) ::<boolean> SG_MACROP)

  (define-c-proc make-macro 
    (name transformer data p1env :optional (maybe_library #f))
    Sg_MakeMacro)

  (define-c-proc macro-env (m::<macro>) (result (-> m env)))

  (define-c-proc make-macro-transformer (name proc p1env library)
    Sg_MakeMacroTransformer)

  (define-c-proc variable-transformer? (o) Sg_VMVariableTransformerP)

  (define-c-proc call-macro-expander (macro::<macro> expr p1env)
    (result (Sg_VMApply4 (-> macro transformer)
			 macro expr p1env (-> macro data))))

  (define-c-proc %internal-macro-expand (expr p1env onceP::<boolean>)
    Sg_MacroExpand)

  ;; library
  (define-c-proc make-library (name) Sg_MakeLibrary)

  (define-c-proc library? (arg0) ::<boolean> SG_LIBRARYP)

  (define-c-proc library-name (arg0::<library>) SG_LIBRARY_NAME)

  (define-c-proc library-imported (arg0::<library>) SG_LIBRARY_IMPORTED)

  (define-c-proc library-imported-set! (arg0::<library> arg1) ::<void>
    (set! (SG_LIBRARY_IMPORTED arg0) arg1))

  (define-c-proc library-exported (arg0::<library>) SG_LIBRARY_EXPORTED)

  (define-c-proc library-exported-set! (arg0::<library> arg1) ::<void>
    (set! (SG_LIBRARY_EXPORTED arg0) arg1))

  (define-c-proc library-exported-add! (arg0::<library> arg1) ::<void>
    (if (SG_FALSEP (SG_LIBRARY_EXPORTED arg0)) ;; not set yet
	(set! (SG_LIBRARY_EXPORTED arg0) arg1)
	(let* ((exports (SG_CAR (SG_LIBRARY_EXPORTED arg0)))
	       (renames (SG_CDR (SG_LIBRARY_EXPORTED arg0))))
	  (set! (SG_LIBRARY_EXPORTED arg0)
		(Sg_Cons (Sg_Append2X exports (SG_CAR arg1))
			 (Sg_Append2X renames (SG_CDR arg1)))))))

  (define-c-proc library-defined (lib) 
    (cond ((SG_LIBRARYP lib) (result (SG_LIBRARY_DEFINEED lib)))
	  ((SG_FALSEP lib) (result (SG_LIBRARY_DEFINEED (Sg_VMCurrentLibrary))))
	  (else (wrong-type-of-argument-violation 'library-defined 
						  "library or #f" lib))))

  (define-c-proc library-defined-add! (lib::<library> v) ::<void>
    (unless (or (SG_SYMBOLP v) (SG_IDENTIFIERP v))
      (wrong-type-of-argument-violation 'library-defined-add!
					"symbol or identifier" v))
    (when (SG_IDENTIFIERP v) (set! v (SG_IDENTIFIER_NAME v)))
    (let ((def (SG_LIBRARY_DEFINEED lib)))
      (when (and (not (SG_FALSEP def)) (SG_FALSEP (Sg_Memq v def)))
	(set! (SG_LIBRARY_DEFINEED lib) (Sg_Cons v def)))))

  (define-c-proc library-table (lib::<library>) SG_LIBRARY_TABLE)

  (define-c-proc library-parents (lib::<library>)
    (result (-> lib parents)))

  (define-c-proc find-library (arg0 createp::<boolean>) Sg_FindLibrary)

  (define-c-proc %insert-binding (libname name value) ::<void>
    (unless (or (SG_SYMBOLP name)
		(SG_IDENTIFIERP name))
      (wrong-type-of-argument-violation '%insert-binding
					"symbol or identifier"
					name))
    (let ((lib::SgObject (Sg_FindLibrary libname TRUE)))
      (Sg_InsertBinding lib name value)))

  (define-c-proc find-binding (arg0 arg1::<symbol> callback) Sg_FindBinding)

  (define-c-proc import-library (to from spec transp) ::<void>
    (Sg_ImportLibraryFullSpec to from spec))

  (define-c-proc vm-current-library (:optional name::<library>)
    (let ((vm::SgVM* (Sg_VM)))
      (if (SG_UNBOUNDP name)
	  (result (-> vm currentLibrary))
	  (begin
	    (set! (-> vm currentLibrary) name)
	    ; dummy
	    (result SG_UNDEF)))))

  ;; gloc
  (define-c-proc gloc-ref (g::<gloc>) SG_GLOC_GET)

  (define-c-proc gloc-set! (g::<gloc> value) ::<void>
    (SG_GLOC_SET g value))

  (define-c-proc gloc-bound? (g::<gloc>) ::<boolean>
    (result (not (SG_UNBOUNDP (SG_GLOC_GET g)))))

  (define-c-proc gloc-const? (g::<gloc>) ::<boolean>
    (result (Sg_GlocConstP g)))

  (define-c-proc gloc-library (g::<gloc>) ::<top>
    (result (-> g library)))

  (define-c-proc gloc-name (g::<gloc>) ::<top>
    (result (-> g name)))

  ;; closure
  (define-c-proc make-toplevel-closure (cb::<code-builder>)
    ;; topleve closure should not have any free variables
    (result (Sg_MakeClosure cb NULL)))


  ;; code-builder
  (define-c-proc make-code-builder ()
    (result (Sg_MakeCodeBuilder 2)))
  (define-c-proc code-builder? (o) ::<boolean> SG_CODE_BUILDERP)

  (define-c-proc cb-emit0! (cb::<code-builder> insn::<fixnum>) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 0 0 SG_UNDEF))

  (define-c-proc cb-emit1! (cb::<code-builder> insn::<fixnum> arg0::<fixnum>) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 0 SG_UNDEF))

  (define-c-proc cb-emit2! (cb::<code-builder> insn::<fixnum> arg0::<fixnum> arg1::<fixnum>) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 arg1 SG_UNDEF))

  (define-c-proc cb-emit0i! (cb::<code-builder> insn::<fixnum> src) ::<void>    
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 0 0 SG_UNDEF)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit1i! (cb::<code-builder> insn::<fixnum> arg0::<fixnum> src) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 0 SG_UNDEF)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit2i! (cb::<code-builder> insn::<fixnum> arg0::<fixnum> arg1::<fixnum> src) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT0 arg0 arg1 SG_UNDEF)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit0o! (cb::<code-builder> insn::<fixnum> obj) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 0 0 obj))

  (define-c-proc cb-emit0oi! (cb::<code-builder> insn::<fixnum> obj src) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 0 0 obj)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-emit1oi! (cb::<code-builder> insn::<fixnum> arg0::<fixnum> obj src) ::<void>
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 arg0 0 obj)
    (Sg_CodeBuilderAddSrc cb insn src))

  (define-c-proc cb-label-set! (cb::<code-builder> label) ::<void>
    (Sg_CodeBuilderLabelSet cb label))

  (define-c-proc cb-emit-closure! (cb::<code-builder> 
				   insn::<fixnum>
				   lambda_cb::<code-builder>
				   name 
				   req_argc::<fixnum>
				   opt::<boolean>
				   freec::<fixnum>
				   max_stack::<fixnum>
				   src) ::<void>
    (set! (SG_CODE_BUILDER_NAME lambda_cb) name)
    (set! (SG_CODE_BUILDER_ARGC lambda_cb) req_argc)
    (set! (SG_CODE_BUILDER_OPTIONAL lambda_cb) opt)
    (set! (SG_CODE_BUILDER_FREEC lambda_cb) freec)
    (set! (SG_CODE_BUILDER_MAX_STACK lambda_cb) max_stack)
    (Sg_CodeBuilderFlush lambda_cb)
    (Sg_CodeBuilderEmit cb insn ARGUMENT1 0 0 lambda_cb)
    (Sg_CodeBuilderAddSrc lambda_cb insn src))

  ;; for local closure
  (define-c-proc cb-emit-local-closure! (cb::<code-builder> 
					 self-pos::<fixnum>
					 lambda_cb::<code-builder>
					 name 
					 req_argc::<fixnum>
					 opt::<boolean>
					 freec::<fixnum>
					 max_stack::<fixnum>
					 src) ::<void>
    (set! (SG_CODE_BUILDER_NAME lambda_cb) name)
    (set! (SG_CODE_BUILDER_ARGC lambda_cb) req_argc)
    (set! (SG_CODE_BUILDER_OPTIONAL lambda_cb) opt)
    (set! (SG_CODE_BUILDER_FREEC lambda_cb) freec)
    (set! (SG_CODE_BUILDER_MAX_STACK lambda_cb) max_stack)
    (Sg_CodeBuilderFlush lambda_cb)
    (Sg_CodeBuilderEmit cb CLOSURE ARGUMENT1 self-pos 0 lambda_cb)
    (Sg_CodeBuilderAddSrc lambda_cb CLOSURE src))

  (define-c-proc code-builder-label-defs (cb::<code-builder>) ::<top>
    (result (-> cb labelDefs)))

  (define-c-proc code-builder-finish-builder (cb::<code-builder> last::<fixnum>)
    (result (Sg_CodeBuilderFinishBuilder cb last)))

  ;; misc
  (define-c-proc vm-r6rs-mode? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_R6RS_MODE)))
  (define-c-proc vm-core-mode? () ::<boolean>
    (result (== (logand (ashr (-> (Sg_VM) flags) 8) #xFF) 0)))
  (define-c-proc vm-no-overwrite? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_OVERWRITE)))

  ;; (%map-cons l1 l2) = (map cons l1 l2)
  (define-c-proc %map-cons (l1 l2)
    (let ((h SG_NIL) (t SG_NIL))
      (while (and (SG_PAIRP l1) (SG_PAIRP l2))
	(SG_APPEND1 h t (Sg_Cons (SG_CAR l1) (SG_CAR l2)))
	(set! l1 (SG_CDR l1))
	(set! l2 (SG_CDR l2)))
      (result h)))

  ;;
  ;;lookup memo
  ;;
  ;; case 1
  ;; (let ((a 1))
  ;;   (let-syntax ((b (syntax-rules () ((_) a)))) ;; <- 1
  ;;     (b)))
  ;; b's frame 
  ;; ((3) (0) (0 (a 1)))
  ;;
  ;; expanded a's envs
  ;; ((0 (b #<macro>)) (0) (0 (a 1)))
  ;;
  ;; This case identifier 'a' must have its defined environment after the
  ;; boundary. So to look it up, first get the id-envs and find the shared
  ;; frame then look up by name. It is ok to have duplicated names, first
  ;; comes first.

  ;; case 2
  ;; (let ((x 'outer))
  ;;   (let-syntax ((m (syntax-rules () ((m) x)))) ;; <- 'outer
  ;;     (let ((x 'inner))
  ;;       (m))))
  
  ;; frame of lookup frame m and expanded x.
  ;; ((0) (0 (x 'inner)) (0 (m #<macro>)) (0) (0 (x 'outer)))
  ;; expanded x's envs
  ;; ((3) (0 (m #<macro>)) (0) (0 (x 'outer)))
  ;; can be resolved by the above way.
  ;;
  ;; case 3
  ;; 
  ;; (define-syntax aif
  ;;   (lambda (x)
  ;;     (syntax-case x ()
  ;;       ((aif expr then else)
  ;;        (with-syntax ((it (datum->syntax #'aif 'it)))
  ;; 	 #'(let ((it expr))
  ;; 	     (if it then else)))))))
  ;; (aif (assq 'a '((a . 1) (b . -2)))
  ;;      (cdr it)
  ;;      it) ;; -> 1
  ;; 
  ;; (let ((it #f))
  ;;   (aif (assq 'a '((a . 1) (b . -2)))
  ;;        (cdr it)
  ;;        it)) ;; ->
  ;; 
  ;; both cases envs of syntax it.
  ;; () ;; #'aif doesn't contain any environment. so it's null
  ;;
  ;; id it (1)
  ;; ((0) (0 (#<id it> '((a . 1) (b . -2)))))
  ;; () ;; <- compiler env frame
  ;;
  ;; id it (2)
  ;; ((0) (0 (#<id it> '((a . 1) (b . -2)))) (0) (0 (it #f)))
  ;; ((0) (0 (it #f))) ;; <- compiler env frame
  ;;
  ;; in this case looking up #<id it> is the same id. so simple comparison
  ;; is good enough. (thus we can't change the expand-syntax's lookup
  ;; pattern variable yet.
  ;;
  ;; if an identifier envs' first frame is (3), this means the identifier
  ;; is template variable/pattern variable. if it doesn't then it means
  ;; it's expanded identifier. the difference between these 2 would be
  ;; considering following case;
  ;; suppose print is an macro
  ;; (let ((a 1)) (print a))
  ;; this case the expanded 'a' will be an identifier but the actual compiler
  ;; frame contains raw symbol like this;
  ;; ((0) (0 (a 1)))
  ;; the way we can find this would be identifier 'a' contains the same
  ;; frame as current compiler environment. 
  ;; (let ((b 2)) (print (let ((a 1)) a)))
  ;; a's env        ((0) (0 (b 2)))
  ;; compiler frame ((0) (0 (#<id a> 1)) (0) (0 (b 2)))
  ;; this case both a are the same identifier and contains non null envs.
  ;; so we compare values with eq? and once identifier reached the same env
  ;; then strip and re-compare again. 
  ;; 
  ;; in this case both 'f and 'g even inside of the compiler frame variable
  ;; will be identifiers. however we still need to check.
  ;; this only happens when symbol becomes an identifier during macro
  ;; expansion. so all converted identifier will have the same env frame.
  ;; in this case we need to add comparison using name and envs.
  ;; (print
  ;;    (let ((f (lambda (x) (+ x 1))))
  ;;      (let-syntax ((f (syntax-rules () ((f x) x)))
  ;;                   (g (syntax-rules () ((g x) (f x)))))
  ;;        (list (f 1) (g 1))))
  ;;    )

  (define-cfn bottom-env? (env) ::int :static
    (return (or (SG_NULLP env)
		(and (SG_PAIRP (SG_CAR env))
		     (SG_EQ ENV-BOTTOM (SG_CAAR env))))))

  ;; it's basically equal? but we don't want to use it because it's heavy
  ;; so simplified version
  (define-cfn %id-env=? (id1 id2)::int :static
    (let ((env1 (SG_IDENTIFIER_ENVS id1))
	  (env2 (SG_IDENTIFIER_ENVS id2)))
      (when (SG_EQ env1 env2) (return TRUE))
      (loop 
       (when (and (SG_NULLP env1) (SG_NULLP env2)) (return TRUE))
       (when (or  (SG_NULLP env1) (SG_NULLP env2)) (return FALSE))
       (let ((p1 (SG_CAR env1))
	     (p2 (SG_CAR env2)))
	 (unless (and (SG_PAIRP p1) (SG_PAIRP p2)) (return FALSE))
	 ;; frame ::= (type . alist-of-lvars)
	 ;; alist-of-lvars ::= (var . lvar)
	 (unless (SG_EQ (SG_CAR p1) (SG_CAR p2)) (return FALSE))
	 (let ((f1 (SG_CDR p1))
	       (f2 (SG_CDR p2)))
	   (loop 
	    (when (and (SG_NULLP f1) (SG_NULLP f2)) (break))
	    (when (or  (SG_NULLP f1) (SG_NULLP f2)) (return FALSE))
	    (unless (and (SG_EQ (SG_CAR f1) (SG_CAR f2))
			 (SG_EQ (SG_CDR f1) (SG_CDR f2)))
	      (return FALSE))
	    (set! f1 (SG_CDR f1))
	    (set! f2 (SG_CDR f2))))
	 (set! env1 (SG_CDR env1))
	 (set! env2 (SG_CDR env2))))))
  
  (define-c-proc id-env=? (id1::<identifier> id2::<identifier>) ::<boolean>
    (result (%id-env=? id1 id2)))

  (define-cfn template-id? (name) ::int :static
    (when (SG_IDENTIFIERP name)
      ;; macro may have internal content so if there is no
      ;; content after the boundary then it's not a template-id.
      (dopairs (fp (SG_IDENTIFIER_ENVS name))
	(when (and (SG_PAIRP (SG_CAR fp))
		   (SG_EQ (SG_CAAR fp) BOUNDARY)
		   (not (bottom-env? (SG_CDR fp))))
	  (return TRUE))))
    (return FALSE))
  (define-cfn template-id-frame (id) :static
    (cond ((template-id? id)
	   (dopairs (fp (SG_IDENTIFIER_ENVS id))
	     (when (and (SG_PAIRP (SG_CAR fp))
			(SG_EQ BOUNDARY (SG_CAAR fp)))
	       (return (SG_CDR fp)))))
	  ((SG_IDENTIFIERP id) (return (SG_IDENTIFIER_ENVS id))))
    (return SG_NIL))

  (define-cfn env-shared? (env frames) ::int :static
    (dopairs (fp frames) (when (SG_EQ env fp) (return TRUE)))
    (return FALSE))

  (define-cfn name=? (name1 name2) ::int :static
    (when (and (SG_IDENTIFIERP name1)
	       (SG_IDENTIFIERP name2)
	       (SG_IDENTIFIER_PENDING name1)
	       (SG_IDENTIFIER_PENDING name2)
	       (or (template-id? name1)
		   (template-id? name2)))
      (return FALSE))
    (let ((s1 name1)
	  (s2 name2))
      ;; env == () means wrapped by p1env-lookup or global
      ;; thus it's the same as global simbol.
      (when (and (SG_IDENTIFIERP name1) 
		 (not (SG_NULLP (SG_IDENTIFIER_ENVS name1)))) 
	(set! s1 (SG_IDENTIFIER_NAME name1)))
      (when (and (SG_IDENTIFIERP name2) 
		 (not (SG_NULLP (SG_IDENTIFIER_ENVS name2)))) 
	(set! s2 (SG_IDENTIFIER_NAME name2)))
      (return (SG_EQ s1 s2))))

  ;; FIXME I have no idea why this works properly.
  ;; the idea is that name-env is the one we are looking up
  ;; and assume it starts with (3) which I believe proper
  ;; template id. Then target-env is the one in the compier
  ;; envs. All of these are sharing a frame the we can consider
  ;; it's the same.
  (define-cfn envs-shared? (name-env target-env frames) ::int :static
    (when (bottom-env? name-env) (return FALSE))
    (when (SG_EQ (SG_CDR name-env) target-env)
      (dopairs (fp frames) (when (SG_EQ fp target-env) (return TRUE))))
    (return FALSE))

  (define-cfn p1env-lookup-inner 
    (p1env::SgVector* name lookup_as frame?::int boundary)
    :static
    (let ((tmpl-id?::int (template-id? name))
	  (id-env (template-id-frame name))
	  (same-env?::int FALSE)
	  (frames (SG_VECTOR_ELEMENT p1env 1))
	  (retried::int FALSE))
      (label retry)
      (dopairs (fp frames)
	(when (or (SG_EQ id-env fp) ;; for template variables
		  ;; for mostly internal define in macro defintion.
		  (and (SG_IDENTIFIERP name)
		       (SG_EQ (SG_IDENTIFIER_ENVS name) fp)))
	  (set! same-env? TRUE))
	;; don't go over boundary
	(when (SG_EQ boundary (SG_CAAR fp)) (return name))
	;; not interesting
	(unless (== (SG_CAAR fp) lookup_as) (continue))
	
	(dolist (vp (SG_CDAR fp))
	  (when (or (SG_EQ name (SG_CAR vp)) ;; simple case
		    ;; if the name is symbol and the target shares the
		    ;; env with the frames, then the target is defined in
		    ;; the same environment as the lookup symbol.
		    (and (SG_SYMBOLP name)
			 (SG_IDENTIFIERP (SG_CAR vp))
			 (SG_EQ name (SG_IDENTIFIER_NAME (SG_CAR vp)))
			 (env-shared? (SG_IDENTIFIER_ENVS (SG_CAR vp)) frames))
		    ;; case 1
		    ;;(and tmpl-id? (name=? name (SG_CAR vp)))
		    ;; in the same-env
		    (and same-env? (name=? name (SG_CAR vp)))
		    ;; wrapped it thing
		    ;; the wrapped it problem is that we need to
		    ;; check if the given name is pure template id
		    ;; (starts with (3)) and all 3 ids share env 
		    ;; (name, vp and frame)
		    (and (SG_IDENTIFIERP name)
			 (SG_IDENTIFIERP (SG_CAR vp))
			 (SG_EQ (SG_IDENTIFIER_NAME name)
				(SG_IDENTIFIER_NAME (SG_CAR vp)))
			 ;;(%id-env=? name (SG_CAR vp))
			 (or (envs-shared? (SG_IDENTIFIER_ENVS name)
					   (SG_IDENTIFIER_ENVS (SG_CAR vp))
					   frames)
			     (envs-shared? (SG_IDENTIFIER_ENVS (SG_CAR vp))
					   (SG_IDENTIFIER_ENVS name)
					   frames)))
		    ;; next-method? problem
		    ;; again not sure if this is correct...
		    ;; if the name is not a template-id? and the env is not
		    ;; shared with frames nor the target identifier,
		    ;; and the target identifier's env is not shared with
		    ;; the current frame when it probably is the one we want.
		    (and (SG_IDENTIFIERP name)
			 (not tmpl-id?)
			 (SG_IDENTIFIERP (SG_CAR vp))
			 (SG_EQ (SG_IDENTIFIER_NAME name) 
				(SG_IDENTIFIER_NAME (SG_CAR vp)))
			 ;; can we assume this is null?
			 (bottom-env? (SG_IDENTIFIER_ENVS (SG_CAR vp)))
			 (not (SG_FALSEP (Sg_Assv BOUNDARY
						  (SG_IDENTIFIER_ENVS name))))
			 ;; must not be a proper template id.
			 (not (SG_EQ BOUNDARY
				     (SG_CAAR (SG_IDENTIFIER_ENVS name))))
			 (not (env-shared? (SG_IDENTIFIER_ENVS name)
					   frames))))
	    (if frame?
		(return fp)
		(return vp)))))
      ;; for local macro thing
      (when (and (not retried) (SG_IDENTIFIERP name)
		 (SG_IDENTIFIER_PENDING name))
	(set! retried TRUE)
	(set! frames (SG_IDENTIFIER_ENVS name))
	(goto retry))
      (return name)))

  (define-cfn p1env-lookup-rec (p1env::SgVector* name lookup-as)
    (return (p1env-lookup-inner p1env name lookup-as FALSE #f)))

  (define-c-proc p1env-lookup 
    (p1env::<vector> name lookup_as :optional (boundary #f))
    (let ((r (p1env-lookup-inner p1env name lookup_as FALSE boundary)))
      (cond ((SG_PAIRP r) (result (SG_CDR r)))
	    ((SG_SYMBOLP r)
	     (let ((lib (SG_VECTOR_ELEMENT p1env 0)))
	       (result (Sg_MakeIdentifier (SG_SYMBOL r) '() (SG_LIBRARY lib)))))
	    (else (result r)))))

  (define-c-proc p1env-lookup-frame (p1env::<vector> name lookup-as)
    (let ((r (p1env-lookup-inner p1env name lookup-as TRUE #f)))
      (if (or (SG_SYMBOLP r) (SG_IDENTIFIERP r))
	  (result SG_NIL)
	  (result r))))

  ;; check all env frames are macro
  (define-cfn check-env-frame (frames) ::int :static
    (dolist (frame frames)
      (unless (and (SG_PAIRP frame) (SG_MACROP (SG_CDR frame)))
	(return TRUE)))
    (return FALSE))

  (define-c-proc p1env-toplevel? (p1env) ::<boolean>
    (dolist (fp (SG_VECTOR_ELEMENT p1env 1))
      (when (and (== (SG_CAR fp) (SG_MAKE_INT 0))
		 ;; if we slice let-syntax then however env contains
		 ;; frame already so we need to check if the frame only
		 ;; contains macro in that case it's toplevel let(rec)-syntax
		 ;; TODO this might cause some problem...
		 (check-env-frame (SG_CDR fp)))
	  (return SG_FALSE)))
    (result TRUE))

  (define-c-proc vm-frame-size () ::<fixnum>
    (result SG_FRAME_SIZE))

  (define-c-proc print-stack-frames () ::<void>
    (Sg_VMPrintFrame))

  (define-c-proc get-stack-trace-object () ::<top>
    (result (Sg_GetStackTrace)))

  ;; optimize
  (define-c-proc vm-noinline-locals? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_INLINE_LOCAL)))

  (define-c-proc vm-nolambda-lifting? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_LAMBDA_LIFT)))

  (define-c-proc vm-nolibrary-inlining? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_LIBRARY_INLINING)))

  (define-c-proc vm-noconstant-inlining? () ::<boolean>
    (result (SG_VM_IS_SET_FLAG (Sg_VM) SG_NO_CONST_INLINING)))
  
  ;; call/pc
  (define-c-proc %call/pc (p::<procedure>) Sg_VMCallPC)
  (define-c-proc %apply0 (p) Sg_Apply0)

  ;; the env needs to be used both transcribe and wrap-symbol
  ;; so that the same symboll will be renamed to the same identifier
  ;; in the same macro.
  (define-c-proc lookup-transformer-env (o)
    (unless (or (SG_SYMBOLP o) (SG_IDENTIFIERP o))
      (wrong-type-of-argument-violation 'add-to-transformer-env!
					"identifier or symbol" o))
    (let* ((vm::SgVM* (Sg_VM)))
      (cond ((SG_IDENTIFIERP o)
	     (let ((r (Sg_Assq (SG_IDENTIFIER_NAME o) (-> vm transEnv))))
	       (if (SG_FALSEP r)
		   (result r)
		   (if (SG_EQ (SG_IDENTIFIER_LIBRARY o) (SG_CADR r))
		       (result (SG_CDDR r))
		       (result SG_FALSE)))))
	    (else
	     (let ((r (Sg_Assq o (-> vm transEnv))))
	       (cond ((SG_FALSEP r) (result r))
		     ((SG_PAIRP (SG_CDR r)) (result #f))
		     (else (result (SG_CDR r)))))))))

  (define-c-proc add-to-transformer-env! (o n)
    (unless (or (SG_SYMBOLP o) (SG_IDENTIFIERP o))
      (wrong-type-of-argument-violation 'add-to-transformer-env!
					"identifier or symbol" o))
    (let ((vm::SgVM* (Sg_VM)))
      (if (SG_IDENTIFIERP o)
	  (set! (-> vm transEnv) (Sg_Acons (SG_IDENTIFIER_NAME o)
					   (Sg_Cons (SG_IDENTIFIER_LIBRARY o)
						    n)
					   (-> vm transEnv)))
	  (set! (-> vm transEnv) (Sg_Acons o n (-> vm transEnv))))
      (result n)))

  (define-c-proc current-transformer-env () (result (-> (Sg_VM) transEnv)))

  ;; misc
  (define-c-proc vm-warn (msg::<string>)
    (let ((vm::SgVM* (Sg_VM)))
      (when (SG_VM_LOG_LEVEL vm SG_WARN_LEVEL)
	(Sg_Printf (-> vm logPort) (UC "WARNING: %A\n") msg))))

  (define-c-proc code-builder->vector (cb::<code-builder>) 
    Sg_CodeBuilderToVector)
  (define-c-proc code-builder-name (cb::<code-builder>) Sg_CodeBuilderFullName)
  (define-c-proc code-builder-maxstack (cb::<code-builder>) ::<fixnum>
    SG_CODE_BUILDER_MAX_STACK)
  (define-c-proc code-builder-argc (cb::<code-builder>) ::<fixnum>
    SG_CODE_BUILDER_ARGC)
  (define-c-proc code-builder-freec (cb::<code-builder>) ::<fixnum>
    SG_CODE_BUILDER_FREEC)
  (define-c-proc code-builder-optional (cb::<code-builder>) ::<fixnum>
    SG_CODE_BUILDER_OPTIONAL)

  (define-c-proc insn-info (insn::<integer>)
    (let* ((i::int64_t     (Sg_GetIntegerS64Clamp insn SG_CLAMP_NONE NULL))
	   (info::InsnInfo* (Sg_LookupInsnName (INSN i))))
      (if info
	  ;; it's better to use record or something?
	  (result (Sg_Values5 (SG_LIST2
			       (Sg_Intern (Sg_MakeStringC (-> info name)))
			       (SG_MAKE_INT (-> info number)))
			      (SG_MAKE_INT (-> info instValues))
			      (SG_MAKE_INT (-> info argc))
			      (SG_MAKE_BOOL (-> info hasSrc))
			      (SG_MAKE_BOOL (-> info label))))
	  (result (Sg_Values5 SG_FALSE SG_FALSE SG_FALSE SG_FALSE SG_FALSE)))))

  ;; for compile time free-identifier=?
  ;; this must be only internal use so we don't check the structure
  (define-c-proc %set-current-usage-env! (env::<vector>) ::<void>
    (set! (-> (Sg_VM) usageEnv) env))
  ;; may needed for future?
  (define-c-proc %set-current-macro-env! (env::<vector>) ::<void>
    (set! (-> (Sg_VM) macroEnv) env))

)
