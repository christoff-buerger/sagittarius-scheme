;; -*- Scheme -*-
#!read-macro=sagittarius/regex
(import (rnrs)
	(clos user)
	(sagittarius control)
	(sagittarius object)
	(sagittarius cgen stub)
	(sagittarius cgen cise)
	(sagittarius cgen unit)
	(sagittarius cgen syntax)
	(sagittarius cgen literal)
	(sagittarius cgen type)
	(sagittarius cgen precomp)
	(sagittarius compiler)
	(srfi :13 strings)
	(srfi :39 parameters)
	(sagittarius vm)
	(sagittarius regex)
	(util file)
	(match)
	(getopt))

;; REMOVE ME
(with-library (sagittarius cgen stub)
  (define-form-parser define-type args
    (unless (<= 2 (length args) 7)
      (error 'define-type "malformed define-type" `(define-type . ,args)))
    (apply make-cgen-type args)))      

(define-form-parser define (name . body)
  (set! *scheme-definitions*
	(cons `(define ,name . ,body) *scheme-definitions*)))

(define *scheme-definitions* '())

(define (compile-scheme-definitions name imports)
  (let ((cb (compile `(library ,name
			(export :all)
			(import ,@imports)
			,@(reverse *scheme-definitions*))
		     (environment '(only (sagittarius) library)))))
    (cgen-literal cb)))

;; at this point all units are compiled
(define (emit-toplevel-executor name imports oexports topcb)
  (define (gen-exports unit)
    (define (collect-names defs)
      (filter-map (match-lambda (('define (name . args) rest ...) name)
				(('define name expr) name)
				(_ #f))
		  defs))
    (append (collect-names (reverse! *scheme-definitions*))
	    (filter-map (lambda (node)
			  (and (is-a? node <c-proc>)
			       (slot-ref node 'scheme-name)))
			(cgen-unit-toplevel-nodes unit))))
  
  (cgen-body "static SgCodeBuilder *toplevel = ")
  (cgen-body (format "   SG_CODE_BUILDER(~a);" (cgen-cexpr topcb)))
  (let ((lib (find-library name #f)) ;; get the library
	(exports (or (and (memq :only-bindings oexports)
			  (gen-exports (cgen-current-unit)))
		     oexports)))
    ;; emit imports
    (for-each (lambda (i)
		;; we don't resolve any condition but for
		;; and for will be ignored
		(cond ((not (pair? i))
		       (cgen-init (format "  Sg_ImportLibrary(~a, ~a);~%"
					  (cgen-cexpr (cgen-literal lib))
					  (cgen-cexpr (cgen-literal i)))))
		      ((eq? (car i) 'for))
		      (else
		       (cgen-init 
			(format "  Sg_ImportLibrary(~a, ~a);~%"
				(cgen-cexpr (cgen-literal lib))
				(cgen-cexpr 
				 (cgen-literal 
				  (string->symbol (format "~a" i)))))))))
	      imports)
    ;; emit exports
    (for-each (lambda (e)
		(cgen-init (format "  SG_APPEND1(h, t, ~a); /* ~a */"
				   (cgen-cexpr (cgen-literal e))
				   (cgen-safe-comment e)))) exports)

    (cgen-init (format "  Sg_LibraryExportedSet(~a, Sg_Cons(h, SG_NIL));~%"
		       (cgen-cexpr (cgen-literal lib))))
    (when (memq :only-bindings oexports)
      (cgen-init (format "  SG_LIBRARY_AUTO_EXPORT(~a) = TRUE;~%"
			 (cgen-cexpr (cgen-literal lib)))))
    (cgen-init (format "  Sg_VM()->currentLibrary = ~a;" 
		       (cgen-cexpr (cgen-literal lib))))
    (cgen-init (format "  Sg_VMExecute(SG_OBJ(toplevel));"))
    (cgen-init "  Sg_VM()->currentLibrary = save;")))

(define (cgen-gen-c form c-file :key (predef-syms '()))
  (set! *scheme-definitions* '())
  (match form
    (('library (names ...)
         ('export exports ...)
	 ('import imports ...)
       defs ...)
    (let1 prefix
	(cgen-safe-name-friendly (string-join (map ->string names) "_"))
      (parameterize ((cgen-current-unit
		      (make <cgen-stub-unit>
			:name names
			:c-file c-file
			:c-name-prefix (string-append prefix "_")
			:preamble '("/*Generated by genstub. Do not edit.*/")
			:init-prologue
			(format "void Sg__Init_~a(SgLibrary *lib) {\n" prefix)
			)))
	(for-each cgen-define predef-syms)
	(cgen-stub-parse-form form)
	(unless (null? *scheme-definitions*)
	  (emit-toplevel-executor names imports exports
				  (compile-scheme-definitions names imports))
	  (cond ((cgen-unit-init-prologue (cgen-current-unit)) =>
		 (lambda (prev)
		   (cgen-unit-init-prologue (cgen-current-unit)
		     (string-append prev
		       "\n  SgObject save = Sg_VM()->currentLibrary;\n"
		       "SgObject t = SG_NIL, h = SG_NIL;\n"))))))
	(cgen-emit-c (cgen-current-unit)))))))

(define (read-with-source :optional (in (current-input-port)))
  (read in :source-info? #t))

(define (gen files force? clean?)
  (define (do-gen f c)
    (define (prompt f c)
      (format #t "~a ...~!" f)
      (let ((form (call-with-input-file f read-with-source)))
	(cgen-gen-c form c))
      (print "done!"))
    (let1 exist? #f
      (if (and (not force?) (file-exists? c))
	  (let ((stub-mtime (file-stat-mtime f))
		(out-mtime  (file-stat-mtime c)))
	    (if (< stub-mtime out-mtime)
		(print "generated file is older than stub file. " c)
		(prompt f c)))
	  (prompt f c))))
  (if clean?
      (print "cleaning generated file from: " files)
      (print (if force? "force " "") "generating files:" files))
  (for-each (^f (let* ((b (path-sans-extension f))
		       (c (format "~a.c" b)))
		  (if clean?
		      (when (file-exists? c) (delete-file c))
		      (do-gen f c))))
	    files))
(define (main args)
  (with-args args
      ((force? (#\f "force") #f #f)
       (clean? (#\c "clean") #f #f))
    (gen (find-files "." :pattern #/\.stub$/ :recursive #f) force? clean?)))
