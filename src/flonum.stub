;; flonum.stub                                -*- mode:scheme; coding:utf-8; -*-
;;
;;  Copyright (c) 2017  Takashi Kato <ktakashi@ymail.com>
;;
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions
;;  are met:
;;
;;  1. Redistributions of source code must retain the above copyright
;;     notice, this list of conditions and the following disclaimer.
;;
;;  2. Redistributions in binary form must reproduce the above copyright
;;     notice, this list of conditions and the following disclaimer in the
;;     documentation and/or other materials provided with the distribution.
;;
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

;; provides SRFI-144 procedures
;; see: https://srfi.schemers.org/srfi-144/srfi-144.html
(library (sagittarius flonums)
    (export :only-bindings)
    (import (core))
(decl-code
 (.define "LIBSAGITTARIUS_BODY")
 (.include <sagittarius.h>
	   <sagittarius/cache.h>
	   "c99_flonum.h"))

(define-type <flonum> "double" "flonum" "SG_FLONUMP" "SG_FLONUM_VALUE"
  "Sg_MakeFlonum" 0)

;; Constructors
(define (flonum n)
  (if (real? n)
      (inexact n)
      (assertion-violation 'flonum "real number required" n)))

(define-c-proc fladjacent (x::<flonum> y::<flonum>) ::<flonum> :constant
  nextafter)
(define-c-proc flcopysign (x::<flonum> y::<flonum>) ::<flonum> :constant
  copysign)
(define-c-proc make-flonum (x::<flonum> n::<fixnum>) ::<flonum> :constant
  ldexp)

;; Accessors
(define-c-proc flinteger-fraction (x::<flonum>) :constant
  (let* ((iptr::double 0.0)
	 (r::double))
    (set! r (modf x (& iptr)))
    (Sg_Values2 (Sg_MakeFlonum r) (Sg_MakeFlonum iptr))))

(define-c-proc flexponent (x::<flonum>) ::<flonum> :constant logb)
(define-c-proc flnormalized-fraction-exponent (x::<flonum>) :constant
  (let* ((r::double 0.0)
	 (e::int 0))
    (set! r (frexp x (& e)))
    (Sg_Values2 (Sg_MakeFlonum r) (SG_MAKE_INT e))))
(define-c-proc flsign-bit (x::<flonum>) ::<fixnum> :constant signbit)

;; predicate
;; TODO move them from null.stub
;; flonum?
;; fl=?
;; fl<?
;; fl>?
;; fl<=?
;; fl>=?
(define (flunordered? x y) (or (flnan? x) (flnan? y)))
;; flinteger?
;; flzero?
;; flpositive?
;; flnegative?
;; flodd?
;; fleven?
;; flfinite?
;; flinfinite?
;; flnan?
(define-c-proc flnormalized (x::<flonum>) ::<boolean> :constant
  (result (== (fpclassify x) FP_NORMAL)))
(define-c-proc fldenormalized (x::<flonum>) ::<boolean> :constant
  (result (== (fpclassify x) FP_SUBNORMAL)))

;; arithmetic
;; flmax
;; flmin
;; fl+
;; fl*
(define-c-proc fl+* (x::<flonum> y::<flonum> z::<flonum>) ::<flonum> :constant
  fma)
;; fl-
;; fl/
;; flabs

)

