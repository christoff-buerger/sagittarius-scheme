;; -*- mode: scheme; coding: utf-8; -*-
(library (sagittarius regex impl)
    (export compile-regex
	    regex-matcher
	    regex-match
	    regex-looking-at
	    regex-find
	    regex-group
	    regex-capture-count
	    regex-replace-all
	    regex-replace-first

	    ;; pred
	    regex-pattern?
	    regex-matcher?

	    dump-regex)
    (import :none)

  (decl-code
   (.define "LIBSAGITTARIUS_BODY")
   (.include <sagittarius.h> <sagittarius/regex.h>))

  (define-c-proc compile-regex (p::<string> :optional
					    (flags::<fixnum> 0)
					    (parse_only::<boolean> #f))
    :no-side-effect
    Sg_CompileRegex)

  (define-c-proc compile-regex-ast (ast :optional (flags::<fixnum> 0))
    :no-side-effect
    Sg_CompileRegexAST)

  (define-c-proc dump-regex (p::<pattern> :optional
					  (port::<port> (Sg_CurrentOutputPort)))
    ::<void>
    Sg_DumpRegex)


  (define-c-proc regex-matcher 
    (p::<pattern> text::<string> 
		  :optional (start::<fixnum> 0) (end::<fixnum> -1))
    :no-side-effect
    Sg_RegexMatcher)

  (define-c-proc regex-matches (m::<matcher>) ::<boolean>
    Sg_RegexMatches)

  (define-c-proc regex-looking-at (m::<matcher>) ::<boolean>
    Sg_RegexLookingAt)

  (define-c-proc regex-find (m::<matcher> :optional (start::<fixnum> -1))
    ::<boolean>
    Sg_RegexFind)

  (define-c-proc regex-group (m::<matcher> :optional group)
    (when (SG_UNBOUNDP group) (set! group (SG_MAKE_INT 0)))
    (unless (or (SG_INTP group) (SG_SYMBOLP group))
      (Sg_WrongTypeOfArgumentViolation 'regex-group
				       (SG_MAKE_STRING "integer or symbol")
				       group SG_NIL))
    (result (Sg_RegexGroup m group)))

  (define-c-proc regex-group-start (m::<matcher> :optional group)
    (when (SG_UNBOUNDP group) (set! group (SG_MAKE_INT 0)))
    (unless (or (SG_INTP group) (SG_SYMBOLP group))
      (Sg_WrongTypeOfArgumentViolation 'regex-group
				       (SG_MAKE_STRING "integer or symbol")
				       group SG_NIL))
    (let ((p::int (Sg_RegexGroupPosition m group TRUE)))
      (if (< p 0)
	  (result SG_FALSE)
	  (result (SG_MAKE_INT p)))))
  (define-c-proc regex-group-end (m::<matcher> :optional group)
    (when (SG_UNBOUNDP group) (set! group (SG_MAKE_INT 0)))
    (unless (or (SG_INTP group) (SG_SYMBOLP group))
      (Sg_WrongTypeOfArgumentViolation 'regex-group
				       (SG_MAKE_STRING "integer or symbol")
				       group SG_NIL))
    (let ((p::int (Sg_RegexGroupPosition m group FALSE)))
      (if (< p 0)
	  (result SG_FALSE)
	  (result (SG_MAKE_INT p)))))

  (define-c-proc regex-after (m::<matcher>)
    (result (Sg_Substring (-> m text)
			  (-> m last)
			  (-> m to))))

  (define-c-proc regex-before (m::<matcher>)
    (result (Sg_Substring (-> m text)
			  (-> m from)
			  (-> m first))))

  (define-c-proc regex-capture-count (m::<matcher>) ::<fixnum> :no-side-effect
    Sg_RegexCaptureCount)

  (define-c-proc regex-first (m::<matcher>) ::<fixnum> :no-side-effect
    (result (-> m first)))

  (define-c-proc regex-last (m::<matcher>) ::<fixnum> :no-side-effect
    (result (-> m last)))

  (define-c-proc regex-replace-all (m::<matcher> replacement)
    (unless (or (SG_STRINGP replacement)
		(SG_PROCEDUREP replacement))
      (Sg_WrongTypeOfArgumentViolation 'regex-replace-all
				       (SG_MAKE_STRING "string or procedure")
				       replacement SG_NIL))
    (result (Sg_RegexReplaceAll m replacement)))

  (define-c-proc regex-replace-first (m::<matcher> replacement)
    (unless (or (SG_STRINGP replacement)
		(SG_PROCEDUREP replacement))
      (Sg_WrongTypeOfArgumentViolation 'regex-replace-all
				       (SG_MAKE_STRING "string or procedure")
				       replacement SG_NIL))
    (result (Sg_RegexReplaceFirst m replacement)))

  (define-c-proc regex-replace (m::<matcher> replacement count::<fixnum>)
    (unless (or (SG_STRINGP replacement)
		(SG_PROCEDUREP replacement))
      (Sg_WrongTypeOfArgumentViolation 'regex-replace-all
				       (SG_MAKE_STRING "string or procedure")
				       replacement SG_NIL))
    (result (Sg_RegexReplace m replacement count)))

  ;; pred
  (define-c-proc regex-pattern? (o) ::<boolean> :constant SG_PATTERNP)
  (define-c-proc regex-matcher? (o) ::<boolean> :constant SG_MATCHERP)

  ;; accessor
  (define-c-proc regex-pattern (p::<pattern>) (result (-> p pattern)))
  (define-c-proc regex-flags (p::<pattern>) ::<fixnum> (result (-> p flags)))
  (define-c-proc regex-ast (p::<pattern>) (result (-> p ast)))
)