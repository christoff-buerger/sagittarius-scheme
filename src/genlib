;; -*- Scheme -*-
#!read-macro=sagittarius/regex
(import (rnrs)
	(rnrs eval)
	(sagittarius cgen precomp)
	(sagittarius regex)
	(sagittarius control)
	(sagittarius compiler procedure)
	(util file)
	(match)
	(getopt)
	(shorten)
	(pp)
	(srfi :1)
	(srfi :13)
	(srfi :26))

;; cancel inliner
(procedure-inliner-set! (find-procedure 'map '(core base)) #f)
(procedure-inliner-set! (find-procedure 'for-each '(core base)) #f)

;; to handle 64 bit error
;; TODO remove this after 0.5.0
(cond-expand
 (64bit
  (import (sagittarius aspect)
	  (sagittarius cgen stub) (sagittarius cgen cise)
	  (sagittarius cgen unit) (sagittarius cgen literal)
	  (sagittarius vm))
  (point-cut
   (sagittarius vm)
   insn-info
   (lambda (insn)
     (set! insn (bitwise-and insn #xFF))
     (proceed)))
  (point-cut
   (sagittarius cgen precomp)
   allocate-code-vector
   (lambda (cv lv full-name)
     (define (alloc-word initval)
       (cgen-allocate-static-datum 'runtime 'SgWord initval))
     (define (loop cv lv count first-cexpr)
       (if (= count (vector-length cv))
	   first-cexpr
	   (let1 insn (vector-ref cv count)
	     (set! insn (bitwise-and insn #x00000000FFFFFFFF))
	     (let-values (((name&insn iv argc src? label?) (insn-info insn)))
	       (let* ((insn-name (car name&insn))
		      (name-info (if first-cexpr
				     ""
				     (format "/* ~a */"
					     (cgen-safe-comment full-name))))
		      (insn-cexpr
		       (alloc-word
			(if (> insn #x80000000)
			    (format "~a-0x~8,'0x   /* ~3d ~a */"
				    name-info (- #x100000000 insn) count
				    (cgen-safe-comment insn-name))
			    (format "~a0x~8,'0x    /* ~3d ~a */"
				    name-info insn count
				    (cgen-safe-comment insn-name)))))
		      (first-cexpr (or first-cexpr insn-cexpr)))
		 (cond (label? 
			(alloc-word (format "SG_WORD(~a)" 
					    (vector-ref cv (+ count 1))))
			(loop cv lv (+ count 2) first-cexpr))
		       ((not (zero? argc))
			(let ((v (vector-ref lv (+ count 1)))
			      (c (cgen-safe-comment 
				  (format "~a" (vector-ref cv (+ count 1))))))
			  (alloc-word
			   (if (cgen-literal-static? v)
			       (format "SG_WORD(~a) /* ~a */" (cgen-cexpr v) c)
			       (format "SG_WORD(SG_UNDEF) /* ~a */" c)))
			  (loop cv lv (+ count 2) first-cexpr)))
		       (else 
			(loop cv lv (+ count 1) first-cexpr))))))))
     (loop cv lv 0 #f)))
  )
 (else #t))

(define-constant +default-compiler+ "../boot/compiler.scm")
;; import specs for compiler 
;; we can use (rnrs) here since it won't be pre-compiled
;; ****CAUTION****
;; DO NOT USE INLINED PROCEDURES SUCH AS map AND for-each
;; So basically we can't use (rnrs)
(define-constant +default-imports+ '("(core)"
				     "(core base)"
				     "(core syntax)"
				     "(core syntax-case)"
				     "(core errors)"
				     "(core misc)"
				     "(rename (match) (match smatch))"
				     "(sagittarius)"
				     "(sagittarius vm)"
				     "(sagittarius vm debug)"
				     "(sagittarius vm instruction)"
				     "(sagittarius compiler util)"
				     "(sagittarius compiler procedure)"))
(define-constant +default-includes+ '("../boot"))

(define (load-compiler options)
  (with-args options
      ((compiler (#\c "compiler") #t +default-compiler+)
       (libs     (#\L "compiler-import") * +default-imports+)
       (include  (#\I "include") * +default-includes+)
       . ignore)
    (let1 form (construct-library-form 
		compiler `("-l" "(sagittarius host compiler)"
			   "-e" "compile"
			   ,@(append-map (lambda (l) (list "-i" l)) libs)
			   ,@(append-map (lambda (i) (list "-I" i)) include)))
      ;;(pp form)
      (eval form (environment '(only (sagittarius) library)
			      'user))
      (find-procedure 'compile '(sagittarius host compiler)))))

(define (name-generator filename libname)
  (define (path-directory filename)
    (let-values (((dir base ext) (decompose-path filename))) dir))
  (let-values (((out-file initfun-name) 
		(default-name-generator filename libname)))
    (let* ((dir (string-split (path-directory filename) #/[\/\\]/))
	   ;; FIXME currently we are using ../boot/... but
	   ;; for future we might move
	   (targets (drop dir 2))
	   (base (string-join targets "_")))
      (values (string-append base (if (zero? (string-length base))
				      "" "_") out-file)
	      initfun-name))))

(define-syntax aif
  (lambda (x)
    (syntax-case x ()
      ((aif expr then else)
       (with-syntax ((it (datum->syntax #'aif 'it)))
	 #'(let ((it expr))
	     (if it then else)))))))

(define (resolve-cond-expand&include forms loadpaths)
  (define marks '(sagittarius sagittarius.scheme.vm))
  (define (find-file base loadpaths)
    (car (filter-map (lambda (dir)
		       (let1 f (build-path dir base)
			 (and (file-exists? f) f))) loadpaths)))
  (define (handle-cond-expand body form)
    (aif (find (lambda (x) (memq (car x) marks)) body)
	 (resolve-include (cdr it))
	 (aif (find (lambda (x) (eq? (car x) 'else)) body)
	      `(begin ,@(resolve-include (cdr it)))
	      (error 'cond-expand "unfulfileld cond-expand" form))))
  (define (resolve-include forms)
    (map (lambda (form) 
	   (match form
	     (('include file)
	      `(begin ,@(map (lambda (sexp)
			       (match sexp
				 (('cond-expand . body)
				  `(begin ,@(handle-cond-expand body sexp)))
				 (_ sexp)))
			     (file->sexp-list (find-file file loadpaths)))))
	     (_ form))) forms))
  (map (lambda (form)
	 (match form
	   (('cond-expand . body)
	    `(begin ,@(handle-cond-expand body form)))
	   (('include . path)
	    `(begin ,@(resolve-include (list form))))
	   (_ form))) forms))

(define (construct-library-form file options)
  (define (read-from-string s) (read (open-string-input-port s)))
  (define (rename-if-needed s libs)
    (let ((n (read-from-string s)))
      (match n
	(('for name bogus ...)
	 (cond ((assoc name libs) => (lambda (s)
				       (cons* 'for (cdr s) bogus)))
	       (else n)))
	(else
	 (cond ((assoc n libs) => cdr)
	       (else n))))))
  (define (resolve-additionals additionals)
    (define (resolve-additional add)
      (let* ((base (path-sans-extension (path-basename add)))
	     (name (list (string->symbol base)))
	     (libname (string-append +replace-prefix+ base))
	     (form (construct-library-form 
		    add (list "-l" libname 
			      "-i" "(except (rnrs) syntax-rules)"
			      "-i" "(sagittarius)"
			      "-i" "(only (compat r7rs) syntax-rules)"))))
	(eval form (environment '(sagittarius)))
	(cons name (read-from-string libname))))
    (map resolve-additional additionals))

  (with-args options
      ((lib (#\l "library") #t (error 'genlib "library name is missing"))
       (imports (#\i "import") * (error 'genlib "import library is missing"))
       (oexports (#\e "export") * #f)
       (additionals (#\a "additional") * '())
       (includes (#\I "include") * '()))
    ;; for now just add
    (let* ((sexp (file->sexp-list file))
	   (enums '())
	   (exports
	    (filter-map (lambda (sexp)
			  (match sexp
			    (('define (name . args) expr ...) name)
			    (('define (? symbol? name) expr) name)
			    (('define-constant (? symbol? name) expr) name)
			    (('define-syntax name expr) name)
			    ;; fxxk!!!
			    (('define-enum name . e*)
			     (set! enums (append e* enums))
			     name)
			    (else #f))) sexp)))
      ;; try not to contaminate the existing library.
      (let* ((libs (resolve-additionals additionals))
	     (form `(library ,(read-from-string lib) 
			(export ,@(if oexports
				      (map read-from-string oexports)
				      (reverse (append exports enums))))
			(import ,@(map (cut rename-if-needed <> libs) imports))
		      ,@(resolve-cond-expand&include sexp includes))))
	form))))

(define (check-timestamp scm-file out-file)
  (when (file-exists? out-file)
    ;; check the timestamp
    (let ((target-mtime (file-stat-mtime scm-file))
	  (precomp-mtime (file-stat-mtime out-file)))
      (when (< target-mtime precomp-mtime)
	(print "generated file id older than target file. " out-file)
	(exit 0)))))

(define (gen file clean? need-construct? force? library-options)
  (define (do-clean libname)
    (let ((filename (name-generator file libname)))
      (when (file-exists? filename) (delete-file filename))))
  (define (get-form/libname)
    (if need-construct?
	(values #f (get-library-name library-options))
	(let1 form (call-with-input-file file read)
	  (values form (cadr form)))))
  (define (get-library-name options)
    (with-args options
	((lib (#\l "library") #t (error 'genlib "library name is missing"))
	 . rest)
      (read (open-string-input-port lib))))
  (if clean? 
      (print "cleaning generated file from: " file)
      (print "generating from file:" file))
  (let ((compiler (load-compiler library-options)))
    (let-values (((form libname) (get-form/libname)))
      (if clean?
	  (do-clean libname)
	  (begin
	    ;; clean needs to be done no matter what
	    (unless force? (check-timestamp file (name-generator file libname)))
	    (cgen-precompile (or form
				 (construct-library-form file library-options))
			     :in-file file
			     :name-generator name-generator
			     :predef-syms '(LIBSAGITTARIUS_BODY)
			     :compiler compiler))))))
(define (main args)
  (with-args (cdr args)
      ((need-construct? (#\n "need-construct") #f #f)
       (in-file (#\f "file") #t (error 'genlib "input file is missing"))
       (clean?  (#\c "clean") #f #f)
       (force?  (#\F "force") #f #f)
      . rest)
    (gen in-file clean? need-construct? force? rest)))
