;; -*- Scheme -*-
#!read-macro=sagittarius/regex
(import (rnrs)
	(rnrs eval)
	(sagittarius cgen precomp)
	(sagittarius regex)
	(sagittarius control)
	(sagittarius compiler procedure)
	(util file)
	(match)
	(getopt)
	(pp)
	(srfi :1)
	(srfi :13)
	(srfi :26))

;; TODO remove this after 0.5.1
(import (sagittarius aspect)
	(clos user)
	(sagittarius object)
	(sagittarius vm)
	(sagittarius cgen literal))

(point-cut
 (sagittarius cgen literal)
 literal-value-hash
 (lambda (literal)
   (define mask #x0fffffff)
   (define (rec val)
     (cond
      ((pair? val) (bitwise-and (+ (rec (car val)) (rec (cdr val))) mask))
      ((vector? val) 
	(fold (^(v r) (bitwise-and (+ (rec v) r) mask)) 0
	      (vector->list val)))
      ((string? val) (bitwise-and (string-hash val) mask))
      ((identifier? val)
       (bitwise-and (+ (rec (id-name val)) (rec (id-library val))) mask))
      (else (eqv-hash val))))
   (rec literal)))

(define-cgen-literal <cgen-scheme-vector> <vector>
  ((values-vec :init-keyword :values-vec))
  (make (value)
    (make <cgen-scheme-vector> :value value
	  :c-name (cgen-allocate-static-datum)
	  :values-vec (vector-map cgen-literal value)))
  (init (self)
	(let* ((values (~ self 'values-vec))
	       (vec    (~ self 'value))
	       (cname (~ self 'c-name))
	       (s     (vector-length values)))
	  (print "  do {")
	  (format #t "     ~a = Sg_MakeVector(~a, SG_FALSE);~%" cname s)
	  (do ((i 0 (+ i 1)) (l values (cdr values)))
	      ((= i s))
	    (format #t "    SG_VECTOR_ELEMENT(~a, ~a) = ~a; /* ~a */~%"
		    cname i (cgen-cexpr (vector-ref l i)) 
		    (cgen-safe-comment (vector-ref vec i))))
	  (print "  } while (0);")))
  (static (self) #f))

;; cancel inliner
(procedure-inliner-set! (find-procedure 'map '(core base)) #f)
(procedure-inliner-set! (find-procedure 'for-each '(core base)) #f)

(define-constant +default-compiler+ "../boot/compiler.scm")
;; import specs for compiler 
;; we can use (rnrs) here since it won't be pre-compiled
;; ****CAUTION****
;; DO NOT USE INLINED PROCEDURES SUCH AS map AND for-each
;; So basically we can't use (rnrs)
(define-constant +default-imports+ '("(core)"
				     "(core base)"
				     "(core syntax)"
				     "(core syntax-case)"
				     "(core errors)"
				     "(core misc)"
				     "(rename (match) (match smatch))"
				     "(sagittarius)"
				     "(sagittarius vm)"
				     "(sagittarius vm debug)"
				     "(sagittarius vm instruction)"
				     "(sagittarius compiler util)"
				     "(sagittarius compiler procedure)"))
(define-constant +default-includes+ '("../boot"))

(define (load-compiler options)
  (with-args options
      ((compiler (#\c "compiler") #t +default-compiler+)
       (libs     (#\L "compiler-import") * +default-imports+)
       (include  (#\I "include") * +default-includes+)
       . ignore)
    (let1 form (construct-library-form 
		compiler `("-l" "(sagittarius host compiler)"
			   "-e" "compile"
			   ,@(append-map (lambda (l) (list "-i" l)) libs)
			   ,@(append-map (lambda (i) (list "-I" i)) include)))
      ;;(pp form)
      (eval form (environment '(only (sagittarius) library)
			      'user))
      (find-procedure 'compile '(sagittarius host compiler)))))

(define (name-generator filename libname)
  (define (path-directory filename)
    (let-values (((dir base ext) (decompose-path filename))) dir))
  (let-values (((out-file initfun-name) 
		(default-name-generator filename libname)))
    (let* ((dir (string-split (path-directory filename) #/[\/\\]/))
	   ;; FIXME currently we are using ../boot/... but
	   ;; for future we might move
	   (targets (drop dir 2))
	   (base (string-join targets "_")))
      (values (string-append base (if (zero? (string-length base))
				      "" "_") out-file)
	      initfun-name))))

(define-syntax aif
  (lambda (x)
    (syntax-case x ()
      ((aif expr then else)
       (with-syntax ((it (datum->syntax #'aif 'it)))
	 #'(let ((it expr))
	     (if it then else)))))))

(define (resolve-cond-expand&include forms loadpaths)
  (define marks '(sagittarius sagittarius.scheme.vm))
  (define (find-file base loadpaths)
    (car (filter-map (lambda (dir)
		       (let1 f (build-path dir base)
			 (and (file-exists? f) f))) loadpaths)))
  (define (handle-cond-expand body form)
    (aif (find (lambda (x) (memq (car x) marks)) body)
	 (resolve-include (cdr it))
	 (aif (find (lambda (x) (eq? (car x) 'else)) body)
	      `(begin ,@(resolve-include (cdr it)))
	      (error 'cond-expand "unfulfileld cond-expand" form))))
  (define (resolve-include forms)
    (map (lambda (form) 
	   (match form
	     (('include file)
	      `(begin ,@(map (lambda (sexp)
			       (match sexp
				 (('cond-expand . body)
				  `(begin ,@(handle-cond-expand body sexp)))
				 (_ sexp)))
			     (file->sexp-list (find-file file loadpaths)))))
	     (_ form))) forms))
  (map (lambda (form)
	 (match form
	   (('cond-expand . body)
	    `(begin ,@(handle-cond-expand body form)))
	   (('include . path)
	    `(begin ,@(resolve-include (list form))))
	   (_ form))) forms))

(define (construct-library-form file options)
  (define (read-from-string s) (read (open-string-input-port s)))
  (define (rename-if-needed s libs)
    (let ((n (read-from-string s)))
      (match n
	(('for name bogus ...)
	 (cond ((assoc name libs) => (lambda (s)
				       (cons* 'for (cdr s) bogus)))
	       (else n)))
	(else
	 (cond ((assoc n libs) => cdr)
	       (else n))))))
  (define (resolve-additionals additionals)
    (define (resolve-additional add)
      (let* ((base (path-sans-extension (path-basename add)))
	     (name (list (string->symbol base)))
	     (libname (string-append +replace-prefix+ base))
	     (form (construct-library-form 
		    add (list "-l" libname 
			      "-i" "(except (rnrs) syntax-rules)"
			      "-i" "(sagittarius)"
			      "-i" "(only (compat r7rs) syntax-rules)"))))
	(eval form (environment '(sagittarius)))
	(cons name (read-from-string libname))))
    (map resolve-additional additionals))

  (with-args options
      ((lib (#\l "library") #t (error 'genlib "library name is missing"))
       (imports (#\i "import") * (error 'genlib "import library is missing"))
       (oexports (#\e "export") * #f)
       (additionals (#\a "additional") * '())
       (includes (#\I "include") * '()))
    ;; for now just add
    (let* ((sexp (file->sexp-list file))
	   (enums '())
	   (exports
	    (filter-map (lambda (sexp)
			  (match sexp
			    (('define (name . args) expr ...) name)
			    (('define (? symbol? name) expr) name)
			    (('define-constant (? symbol? name) expr) name)
			    (('define-syntax name expr) name)
			    ;; fxxk!!!
			    (('define-enum name . e*)
			     (set! enums (append e* enums))
			     name)
			    (else #f))) sexp)))
      ;; try not to contaminate the existing library.
      (let* ((libs (resolve-additionals additionals))
	     (form `(library ,(read-from-string lib) 
			(export ,@(if oexports
				      (map read-from-string oexports)
				      (reverse (append exports enums))))
			(import ,@(map (cut rename-if-needed <> libs) imports))
		      ,@(resolve-cond-expand&include sexp includes))))
	form))))

(define (check-timestamp scm-file out-file)
  (when (file-exists? out-file)
    ;; check the timestamp
    (let ((target-mtime (file-stat-mtime scm-file))
	  (precomp-mtime (file-stat-mtime out-file)))
      (when (< target-mtime precomp-mtime)
	(print "generated file id older than target file. " out-file)
	(exit 0)))))

(define (gen file clean? need-construct? force? library-options)
  (define (do-clean libname)
    (let ((filename (name-generator file libname)))
      (when (file-exists? filename) (delete-file filename))))
  (define (get-form/libname)
    (if need-construct?
	(values #f (get-library-name library-options))
	(let1 form (call-with-input-file file read)
	  (values form (cadr form)))))
  (define (get-library-name options)
    (with-args options
	((lib (#\l "library") #t (error 'genlib "library name is missing"))
	 . rest)
      (read (open-string-input-port lib))))
  (if clean? 
      (print "cleaning generated file from: " file)
      (print "generating from file:" file))
  (let ((compiler (load-compiler library-options)))
    (let-values (((form libname) (get-form/libname)))
      (if clean?
	  (do-clean libname)
	  (begin
	    ;; clean needs to be done no matter what
	    (unless force? (check-timestamp file (name-generator file libname)))
	    (cgen-precompile (or form
				 (construct-library-form file library-options))
			     :in-file file
			     :name-generator name-generator
			     :predef-syms '(LIBSAGITTARIUS_BODY)
			     :compiler compiler))))))
(define (main args)
  (with-args (cdr args)
      ((need-construct? (#\n "need-construct") #f #f)
       (in-file (#\f "file") #t (error 'genlib "input file is missing"))
       (clean?  (#\c "clean") #f #f)
       (force?  (#\F "force") #f #f)
      . rest)
    (gen in-file clean? need-construct? force? rest)))
