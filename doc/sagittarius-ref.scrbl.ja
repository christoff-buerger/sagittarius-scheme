@; -*- mode:scribble; coding: utf-8 -*-
@title{Sagittarius ユーザーガイド}

このドキュメントはR6RS/R7RS Scheme処理系Sagittariusバージョン@eval{(sagittarius-version)}のマニュアルです。

@table-of-contents[:id "table-of-contents"]

@section{はじめに}

これはScheme処理系Sagittariusのユーザーガイド兼リファレンスマニュアルです。ここでは
R6RSに準拠していない部分の説明をします。

この文書の対象読者は既にSchemeを知っていて何らかのプログラムをSagittarius上で書こう
としている人としています。

@subsection{Sagittariusの概要}

SagittariusはSchemeスクリプトエンジンです。Schemeプログラムを読み込み、コンパイ
ルし仮想マシン上で実行します。Sagittariusは"Revised^6 Report on the Algorithmic
Language Scheme"(R6RS)に及び"Revised^7 Report on the Algorithmic Language
Scheme"(R7RS)に準拠し、またいくつかの"Scheme Requests for　Implementation"
(SRFI)で定められたライブラリを提供します。

Scheme処理系は沢山あり、それぞれ特徴があります。Sagittariusは「柔軟性」と「扱い
やすさ」を念頭に置いて作成されています。R6RSは仕様上厳しい要求を処理系に課して
いますが、それは時として足枷になることがあります。そこで、Sagittariusはデフォル
トではそれらのいくつかの要求を緩めていることがあります。この振る舞いは起動オプ
ションで変えることが可能です。

可搬性の喪失や意図しない振る舞いを避けるため、ここでデフォルトで標準に準拠しな
い部分を挙げます。

@dl-list[]{
@dl-item["リーダー(Reader)"]{

リーダーは3つのモードがあります。一つはR6RSモード。一つはR7RSモード。そしてコン
 パチブルモードです。ユーザーはリーダーマクロでリーダーの振る舞いを変えることが
 できるので、これらのモードはあくまでデフォルトこのように振る舞うリーダーが3つ
 あるとだけといえます。これら3つのモードは@code{#!r6rs}、 @code{#!r7rs} もしく
 は @code{#!compatible}ディレクティブで切り替えることが可能です。詳しくは
 @secref["lib.sagittarius.reader.predefined"]{Predefined reader macros}を参照し
 てください。
 }
 
 @dl-item["その他"]{

エクスポートされた束縛再定義が可能です。この振る舞いは起動オプションで@code{-r6}を指定することで禁止することが可能です。

また、複数のインポート句での同名シンボルのインポートもエラーを挙げません。その際には最も最後にインポートされたライブラリの束縛が使用されます。
}
}

@subsection{表記}

このマニュアルではそれぞれのエントリーは以下のように表示されます。

@define[カテゴリ]{@name{foo} @args{arg1 arg2}}
@desc{[標準] 説明 @dots{}}

@var{カテゴリ} はエントリ@b{foo}のカテゴリを意味します。以下のカテゴリがこのマ
ニュアルでは使用されます。

@dl-list[
@dl-item["Program"]{コマンドラインプログラム}
@dl-item["Function"]{Schemeの手続き}
@dl-item["Syntax"]{構文}
@dl-item["Auxiliary Syntax"]{補助構文}
@dl-item["Macro"]{マクロ}
@dl-item["Auxiliary Macro"]{補助マクロ}
@dl-item["Library"]{ライブラリ}
@dl-item["Condition Type"]{コンディション型}
@dl-item["Reader Macro"]{リーダーマクロ}
@dl-item["Class"]{CLOSのクラス}
@dl-item["Generic"]{総称関数}
@dl-item["Method"]{メソッド}
]

手続き、構文及びマクロではエントリーは一つ以上の引数を持つことがあります。引数
のリストでは以下の表記が用いられます。

@dl-list[
@dl-item[@var{arg @dots{}}]{0個以上の引数を受け取ることを示します。}
@dl-itemx[2 @var{:optional x y z} 
	    @var{:optional (x x-default) (y y-default) (z z-default)}]{
3つまでのオプショナル引数を受け取ることを示します。二つ目のフォームは@var{x}、@var{y}及び@var{z}の既定の値を明示しています。}
]

The description of the entry follows the entry line. If the specification of the
entry comes from some standard or implementation, its origin is noted in the
bracket at the beginning of the description. The following origins are noted:

@dl-list[
@dl-itemx[2 "[R6RS]" "[R6RS+]"]{
The entry works as specified in "Revised^6 Report on the Algorithmic Language
Scheme.". If it is marked as "[R6RS+]", the entry has additional functionality.}
@dl-item["[R7RS]"]{
The entry works as specified in "Revised^7 Report on the Algorithmic Language
Scheme."(draft 5).}
@dl-itemx[2 "[SRFI-n]" "[SRFI-n+]"]{The entry works as specified in SRFI-n. If
it is marked as "[SRFI-n+]", the entry has additional functionality.}
]

@section{Programming in Sagittarius}

@subsection{Invoking Sagittarius}

Sagittarius can be used either as an independent Schame interpreter or an
embedded Scheme library. The interpreter which comes with Sagittarius
distribution is a program named @code{sagittarius} on Unix like environment
and @code{sash} on Windows environment. 

@define[Program]{@name{sagittarius} @args{[options] scheme-file arg @dots{}}}
@desc{Invoking sagittarius. If @var{scheme-file} is not given, it runs with
interactive mode.

Specifying @code{-r} option with Scheme standard number, currently @code{6}
and @code{7} are supported, forces to run Sagittarius on strict standard
mode. For example, entire script is read then evaluated on R6RS 
(@code{-r6} option) mode. Thus macros can be located below the main script.

Detail options are given with option @code{"-h"}.}

For backward compatibility, symbolic link @code{sash} is also provided
on Unix like environment. However this may not exist if Sagittarius is built
with disabling symbolic link option.

@subsection{Writing Scheme scripts}

When a Scheme file is given to @code{sash}, it bounds an internal variable to
list of the remaining command-line arguments which you can get with the 
@code{command-line} procedure, then loads the Scheme program. If the first line
of scheme-file begins with @code{"#!"}, then sash ignores the entire line. This 
is useful to write a Scheme program that works as an executable script in
unix-like systems.

Typical Sagittarius script has the first line like this:

@snipet{#!/usr/local/bin/sagittarius}

or

@snipet{#!/bin/env sagittarius}

The second form uses "shell trampoline" technique so that the script works as
far as sash is in the PATH.

After the script file is successfully loaded, then sash will process all
toplevel expression the same as Perl.

Now I show a simple example below. This script works like @code{cat(1)}, without
any command-line option processing and error handling.

@codeblock{
#!/usr/local/bin/sagittarius
(import (rnrs))
(let ((args (command-line)))
  (unless (null? (cdr args))
    (for-each (lambda (file)
		(call-with-input-file file
		  (lambda (in)
		    (display (get-string-all in)))))
	      (cdr args)))
  0)
}

If the script file contains @code{main} procedure, then Sagittarius execute
it as well with one argument which contains all command line arguments. This
feature is defined in 
@hyperlink[:href "http://srfi.schemers.org/srfi-22/"]{SRFI-22}. So the
above example can also be written like the following:

@codeblock{
#!/usr/local/bin/sagittarius
(import (rnrs))
(define (main args)
  (unless (null? (cdr args))
    (for-each (lambda (file)
		(call-with-input-file file
		  (lambda (in)
		    (display (get-string-all in)))))
	      (cdr args)))
  0)
}

NOTE: the @code{main} procedure is called after all toplevel expressions
are executed.

@subsection{Working on REPL}

If @code{sagittarius} does not get any script file to process, then it will
go in to REPL (read-eval-print-loop). For developers' convenience, REPL
imports some libraries by default such as @code{(rnrs)}.

If @code{.sashrc} file is located in the directory indicated @code{HOME} or
@code{USERPROFILE} environment variable, then REPL reads it before evaluating
user input. So developer can pre-load some more libraries, instead of typing
each time.

NOTE: @code{.sashrc} is only for REPL, it is developers duty to load all
libraries on script file.

@subsection{Writing a library}

Sagittarius provides 2 styles to write a library, one is R6RS style and other
one is R7RS style. Both styles are processed the same and users can use it
without losing code portability.

Following example is written in R6RS style, for the detail of @code{library}
syntax please see the R6RS document described in bellow sections.
@codeblock{
(library (foo)
  (export bar)
  (import (rnrs))

 (define bar 'bar)
)
}
The library named @code{(foo)} must be saved the file named @code{foo.scm},
@code{foo.ss} or @code{foo.sls} (I use @code{.scm} for all examples) and
located on the loading path, the value is returned by calling
@code{add-load-path} with 0 length string.

If you want to write portable code, then you can write implementation specific
code separately using @code{.sagittarius.scm}, @code{.sagittarius.ss} or
@code{.sagittarius.sls} extensions.

If you don't want to share a library but only used in specific one, you can
write both in one file and name the file you want to show. For example;
@codeblock{
(library (not showing)
  ;; exports all internal use procedures
  (export ...)
  (import (rnrs))
;; write procedures
...
)

(library (shared)
  (export shared-procedure ...)
  (import (rnrs) (not showing))
;; write shared procedures here
)
}
Above script must be saved the file named @code{shared.scm}. The order of
libraries are important. Top most dependency must be the first and next is
second most, so on.

Note: This style can hide some private procedures however if you want to write
portable code, some implementations do not allow you to write this style.

@subsection{Compiled cache}

For better starting time, Sagittarius caches compiled libraries. The cache files
are stored in one of the following environment variables;

For Unix like (POSIX) environment:
@itemlist[
  @item{@code{SAGITTARIUS_CACHE_DIR}}
  @item{@code{HOME}}
]

For Windows environment:
@itemlist[
  @item{@code{SAGITTARIUS_CACHE_DIR}}
  @item{@code{TEMP}}
  @item{@code{TMP}}
]

Sagittarius will use the variables respectively, so if the
@code{SAGITTARIUS_CACHE_DIR} is found then it will be used.

The caching compiled file is carefully designed however the cache file might be
stored in broken state. In that case use @code{-c} option with
@code{sagittarius}, then it will wipe all cache files. If you don't want to use
it, pass @code{-d} option then Sagittarius won't use it.

@subsubsection{Precompiling cache file}

Users can provide own library with precompile script. The script looks like
this;

@codeblock{
(import (the-library-1)
        (the-library-2))
}

When this script is run, then the libraries will be cached in the cache
directory.

Note: The cache files are stored with the names converted from original library
files' absolute path. So it is important that users' libraries are already
installed before precompiling, otherwise Sagittarius won't use the precompiled
cache files.

@include-section["r6rs.scrbl"]
@include-section["r7rs.scrbl"]
@include-section["clos.scrbl"]
@include-section["sagittarius.scrbl"]
@include-section["utils.scrbl"]
@include-section["ported.scrbl"]
@include-section["srfi.scrbl"]
@section[:appendix "A" :tag "index"]{Index}

@index-table[:id "index-table"]
@author["Takashi Kato"]