[ยง2] (rfc zlib) - zlib compression library {#rfc.zlib}
-------------

###### [!Library] `(rfc zlib)` 

This library provides the binding for zlib compression library. For now,
it only provides the highest level APIs.


###### [!Condition Type] `&zlib-error` 
###### [!Function] `zlib-error?`  _obj_
###### [!Function] `condition-zlib-stream`  _zlib-error_

Subcondition of `&error`.

This condition is raised when zlib process is finished unsuccessfully. You can
obtain the cause z-stream with the `condition-zlib-stream` procedure and
get the detail message with the `zlib-error-message` procedure. When error
occurred, however, it is raised with `message-condition` and it has the
error message with. So you can simply get it with `condition-message`procedure.


###### [!Function] `zlib-error-message`  _z-stream_

_Z-stream_ must be z-stream object.

Retrieve error message from _z-stream_. If _z-stream_ does not have any
error message and this procedure is called, the behaviour is unspecified.


###### [!Function] `open-deflating-output-port`  _sink_ _:key_ _compression-level_ _buffer-size_ _window-bits_ _memory-level_ _
_ _strategy_ _dictionary_ _owner?_

_Sink_ must be binary output port. Creates a custom binary output
port. The port deflates its input and put the result to _sink_. With the
optional keys, you can specify the following conditions:

_compression-level_
: You can specify an exact integer between 1 and 9 (inclusive) to
  _compression-level_. When it is omitted, a default compression level is
  used, which is usually 6.
  The following constants are defined to specify _compression-level_conveniently:
  ###### [!Constant] `Z_NO_COMPRESSION` 
  ###### [!Constant] `Z_BEST_SPEED` 
  ###### [!Constant] `Z_BEST_COMPRESSION` 
  ###### [!Constant] `Z_DEFAULT_COMPRESSION` 

_buffer-size_
: It specifies the buffer size of the port in bytes.
  The default is 4096.

_window-bits_
: It specifies the size of the window in exact
  integer. Typically the value should be between 8 and 15, inclusive, and it
  specifies the base two logarithm of the window size used in compression. Larger
  number yields better compression ratio, but more memory usage. The default value
  is 15.

_memory-level_
: It specifies how much memory should be allocated to
  keep the internal state during compression. 1 means smallest memory which causes
  slow and less compression. 9 means fastest and best compression with the largest
  amount of memory. The default value is 8.

_strategy_
: To fine tune compression algorithm, you can use the
  _strategy_ argument. The following constants are defined as the valid value
  as _strategy_.
  ###### [!Constant] `Z_DEFAULT_STRATEGY` 
  The default strategy, suitable for most ordinary data.
  ###### [!Constant] `Z_FILTERED` 
  Suitable for data generated by filters (or predictors). Filtered data
  consists mostly of small values with a somewhat compress them better. The
  effect of this is to force more huffman coding and less string matching.
  ###### [!Constant] `Z_HUFFMAN_ONLY` 
  Force to use huffman encoding only.
  ###### [!Constant] `Z_RLE` 
  This is designed to be almost as fast as Z_HUFFMAN_ONLY, but gives better
  compression for PNG image data.
  ###### [!Constant] `Z_FIXED` 
  This prevents the use of dynamic huffman codes, allowing for a simpler
  decoder for special applications.
  The choice of _strategy_ only affects compression ratio and speed. Any
  choice produces correct and decompressable data.

_dictionary_
: You can give an initial dictionary to the
  _dictionary_ argument to be used in compression. The compressor and
  decompressor must use exactly the same dictionary.

_owner?_
: If this argument is specified true value, the created
  port automatically closes the given output port _sink_ when it is closed.



###### [!Function] `open-inflating-input-port`  _source_ _:key_ _buffer-size_ _window-bits_ _dictionary_ _owner?_

_Source_ must be a binary input port.

The `open-inflating-input-port` creates a custom binary input port, which
reads compressed binary data from the given port _source_ and decompresses
the read data. When _source_ port supports both `port-position` and
`set-port-position!` then the procedure will set _source_ position
to offset of used bytes length when the created custom port is being closed.
Thus if the _source_ port contains mixture of deflated data and non
deflated data then the custom port will only read deflated data and won't
forward the original port position beyond it no matter how big the
_buffer-size_ is specified.

The meaning of _buffer-size_ is the same as
 `open-deflating-output-port`.

The meaning of _window-bits_ is almost the same, except if a value increased
by 32 is given, the inflating port automatically detecs whether the source
stream is zlib or gzip by its header.

If the input data is compressed with specified dictionary, the same dictionary
must be given to _dictionary_ argument. Otherwise &zlib-error condition is
raised.


###### [!Function] `inflate-bytevector`  _bv_ _opts_ _..._
###### [!Function] `deflate-bytevector`  _bv_ _opts_ _..._

Inflate/deflate given bytevector _bv_ respectively.

These are convenient procedures. It uses `open-inflating-input-port` or
`open-deflating-output-port` to inflate/deflate.

The _opts_ will be passed to underlying procedures.


###### [!Function] `crc32`  _bv_ _:optional_ _(checksum_ _0)_
###### [!Function] `adler32`  _bv_ _:optional_ _(checksum_ _0)_

Returns CSC32/Adler32 checksum of bytevector _bv_, respectively.

If optional _checksum_ is given, then returned checksum is an update of
_checksum_ by _bv_.


